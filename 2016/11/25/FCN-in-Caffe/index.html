<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>FCN in Caffe | 简说</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在学习了FCN之后特别地兴奋, 也许这就是网络结构的创意带来的思路上的刺激感吧, 于是开始跑一个FCN试试, 还是觉得 Siftflow-fcn8s 比较靠谱, 一个是数据量适当, 另一个是训练任务比较适合现在正在做的事情, 于是训练了一下官方demo, 之后又训练了Pascal-context的任务">
<meta name="keywords" content="FCN">
<meta property="og:type" content="article">
<meta property="og:title" content="FCN in Caffe">
<meta property="og:url" content="http://simtalk.cn/2016/11/25/FCN-in-Caffe/index.html">
<meta property="og:site_name" content="简说">
<meta property="og:description" content="在学习了FCN之后特别地兴奋, 也许这就是网络结构的创意带来的思路上的刺激感吧, 于是开始跑一个FCN试试, 还是觉得 Siftflow-fcn8s 比较靠谱, 一个是数据量适当, 另一个是训练任务比较适合现在正在做的事情, 于是训练了一下官方demo, 之后又训练了Pascal-context的任务">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://simtalk.cn/img/FCN-in-Caffe/siftflow-fcn8s.png">
<meta property="og:image" content="http://simtalk.cn/img/FCN-in-Caffe/pascal-fcn8s.png">
<meta property="og:updated_time" content="2018-06-02T05:28:22.947Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="FCN in Caffe">
<meta name="twitter:description" content="在学习了FCN之后特别地兴奋, 也许这就是网络结构的创意带来的思路上的刺激感吧, 于是开始跑一个FCN试试, 还是觉得 Siftflow-fcn8s 比较靠谱, 一个是数据量适当, 另一个是训练任务比较适合现在正在做的事情, 于是训练了一下官方demo, 之后又训练了Pascal-context的任务">
<meta name="twitter:image" content="http://simtalk.cn/img/FCN-in-Caffe/siftflow-fcn8s.png">
  
    <link rel="alternative" href="/atom.xml" title="简说" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xqkff.com1.z0.glb.clouddn.com/AIer.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">simshang</a></h1>
		</hgroup>

		
		<p class="header-subtitle">英泰勒吉斯就一定要实现</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/categories/life">生活</a></li>
				        
							<li><a href="/categories/Ukelele">音乐</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Simshang" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/shangyan" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=l_T-9vnwue72_dfx_O-69v77ufT4_g" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/proto/" style="font-size: 10px;">.proto</a> <a href="/tags/3dConv/" style="font-size: 10px;">3dConv</a> <a href="/tags/AlexNet/" style="font-size: 10px;">AlexNet</a> <a href="/tags/BN/" style="font-size: 10px;">BN</a> <a href="/tags/BRIEF/" style="font-size: 10px;">BRIEF</a> <a href="/tags/BigO/" style="font-size: 10px;">BigO</a> <a href="/tags/Blobs/" style="font-size: 10px;">Blobs</a> <a href="/tags/BoW/" style="font-size: 10px;">BoW</a> <a href="/tags/C/" style="font-size: 14px;">C++</a> <a href="/tags/CDC/" style="font-size: 10px;">CDC</a> <a href="/tags/CNN/" style="font-size: 10px;">CNN</a> <a href="/tags/Caffe/" style="font-size: 18px;">Caffe</a> <a href="/tags/Container/" style="font-size: 10px;">Container</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Dockerhub/" style="font-size: 10px;">Dockerhub</a> <a href="/tags/Dropout/" style="font-size: 10px;">Dropout</a> <a href="/tags/FCN/" style="font-size: 12px;">FCN</a> <a href="/tags/FTP/" style="font-size: 10px;">FTP</a> <a href="/tags/GBD/" style="font-size: 10px;">GBD</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/GoogLeNet/" style="font-size: 10px;">GoogLeNet</a> <a href="/tags/Harris/" style="font-size: 10px;">Harris</a> <a href="/tags/Hexo/" style="font-size: 14px;">Hexo</a> <a href="/tags/IDE/" style="font-size: 10px;">IDE</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/LSTM/" style="font-size: 10px;">LSTM</a> <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/Layers/" style="font-size: 12px;">Layers</a> <a href="/tags/Linux/" style="font-size: 12px;">Linux</a> <a href="/tags/Make/" style="font-size: 10px;">Make</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Mysql/" style="font-size: 16px;">Mysql</a> <a href="/tags/NIN/" style="font-size: 10px;">NIN</a> <a href="/tags/Nets/" style="font-size: 10px;">Nets</a> <a href="/tags/ORB/" style="font-size: 10px;">ORB</a> <a href="/tags/OS/" style="font-size: 12px;">OS</a> <a href="/tags/Paddle/" style="font-size: 12px;">Paddle</a> <a href="/tags/PyCaffe/" style="font-size: 10px;">PyCaffe</a> <a href="/tags/Python/" style="font-size: 12px;">Python</a> <a href="/tags/RNN/" style="font-size: 10px;">RNN</a> <a href="/tags/ResNet/" style="font-size: 10px;">ResNet</a> <a href="/tags/SIFT/" style="font-size: 10px;">SIFT</a> <a href="/tags/SURF/" style="font-size: 10px;">SURF</a> <a href="/tags/SVM/" style="font-size: 10px;">SVM</a> <a href="/tags/Shell/" style="font-size: 10px;">Shell</a> <a href="/tags/Softmax/" style="font-size: 10px;">Softmax</a> <a href="/tags/Staple/" style="font-size: 10px;">Staple</a> <a href="/tags/TensorFlow/" style="font-size: 12px;">TensorFlow</a> <a href="/tags/UML/" style="font-size: 10px;">UML</a> <a href="/tags/VGG/" style="font-size: 10px;">VGG</a> <a href="/tags/Vim/" style="font-size: 10px;">Vim</a> <a href="/tags/kNN/" style="font-size: 10px;">kNN</a> <a href="/tags/内存/" style="font-size: 10px;">内存</a> <a href="/tags/单元测试/" style="font-size: 10px;">单元测试</a> <a href="/tags/反向传播算法/" style="font-size: 10px;">反向传播算法</a> <a href="/tags/图像增强/" style="font-size: 10px;">图像增强</a> <a href="/tags/图说/" style="font-size: 20px;">图说</a> <a href="/tags/工厂模式/" style="font-size: 10px;">工厂模式</a> <a href="/tags/并发编程/" style="font-size: 10px;">并发编程</a> <a href="/tags/摇滚/" style="font-size: 14px;">摇滚</a> <a href="/tags/文本分类/" style="font-size: 10px;">文本分类</a> <a href="/tags/最小二乘法/" style="font-size: 10px;">最小二乘法</a> <a href="/tags/梯度下降法/" style="font-size: 14px;">梯度下降法</a> <a href="/tags/模型优化/" style="font-size: 12px;">模型优化</a> <a href="/tags/正则化/" style="font-size: 12px;">正则化</a> <a href="/tags/激活函数/" style="font-size: 10px;">激活函数</a> <a href="/tags/电影/" style="font-size: 10px;">电影</a> <a href="/tags/神经网络/" style="font-size: 12px;">神经网络</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/线性模型/" style="font-size: 12px;">线性模型</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/随笔/" style="font-size: 12px;">随笔</a> <a href="/tags/面向对象/" style="font-size: 10px;">面向对象</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">北邮在读，计算机视觉与深度学习，喜欢摇滚乐，爱打篮球，极简主义。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">simshang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xqkff.com1.z0.glb.clouddn.com/AIer.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">simshang</h1>
			</hgroup>
			
			<p class="header-subtitle">英泰勒吉斯就一定要实现</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/categories/life">生活</a></li>
		        
					<li><a href="/categories/Ukelele">音乐</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Simshang" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/shangyan" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=l_T-9vnwue72_dfx_O-69v77ufT4_g" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-FCN-in-Caffe" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/25/FCN-in-Caffe/" class="article-date">
  	<time datetime="2016-11-25T02:18:36.000Z" itemprop="datePublished">2016-11-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      FCN in Caffe
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/FCN/">FCN</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Caffe/">Caffe</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <div id="toc" class="toc-article">
            <strong class="toc-title">文章目录</strong>
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#siftflow-fcn8s"><span class="toc-text">siftflow-fcn8s</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#网络结构"><span class="toc-text">网络结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#训练步骤"><span class="toc-text">训练步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-Layer"><span class="toc-text">Python Layer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构建网络"><span class="toc-text">构建网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solver-prototxt"><span class="toc-text">solver.prototxt</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pascal-Context"><span class="toc-text">Pascal-Context</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#网络结构-1"><span class="toc-text">网络结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-Layer-1"><span class="toc-text">Python Layer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#训练模型"><span class="toc-text">训练模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#相关资料"><span class="toc-text">相关资料</span></a></li></ol>
        </div>
        
        <p>在学习了FCN之后特别地兴奋, 也许这就是网络结构的创意带来的思路上的刺激感吧, 于是开始跑一个FCN试试, 还是觉得 <a href="https://github.com/shelhamer/fcn.berkeleyvision.org" target="_blank" rel="noopener">Siftflow-fcn8s</a> 比较靠谱, 一个是数据量适当, 另一个是训练任务比较适合现在正在做的事情, 于是训练了一下官方demo, 之后又训练了Pascal-context的任务</p>
<a id="more"></a>
<blockquote>
<p>理论部分参考我的另一篇文章: <a href="http://simtalk.cn/2016/11/01/Fully-Convolutional-Networks/">Fully Convolutional Networks</a></p>
</blockquote>
<blockquote>
<p>原论文 : <a href="https://arxiv.org/abs/1411.4038" target="_blank" rel="noopener">Fully Convolutional Networks for Semantic Segmentation</a></p>
</blockquote>
<h2 id="siftflow-fcn8s"><a href="#siftflow-fcn8s" class="headerlink" title="siftflow-fcn8s"></a><strong>siftflow-fcn8s</strong></h2><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a><strong>网络结构</strong></h3><ul>
<li>在 <a href="https://github.com/shelhamer/fcn.berkeleyvision.org/blob/master/data/sift-flow/README.md" target="_blank" rel="noopener">sift-flow数据集</a>上有两个任务，一个是语义分割(33类+背景类)；另一个是几何分割(3类+背景类), 用caffe自带的工具将siftflow-fcn8s的网路结构画出来, 由下图可知, 该网络完成了两个任务的训练</li>
</ul>
<p><img src="/img/FCN-in-Caffe/siftflow-fcn8s.png" alt=""></p>
<h3 id="训练步骤"><a href="#训练步骤" class="headerlink" title="训练步骤"></a><strong>训练步骤</strong></h3><blockquote>
<p>在Github上clone代码: <a href="https://github.com/shelhamer/fcn.berkeleyvision.org" target="_blank" rel="noopener">FCN代码</a></p>
</blockquote>
<ol>
<li><p>数据准备:将下载的数据集解压到<code>fcn.berkeleyvision.org/data/sift-flow</code></p>
</li>
<li><p>将<code>siftflow_layers.py</code>和<code>surgery.py</code>还有<code>score.py</code>文件复制到<code>fcn.berkeleyvision.org/siftflow-fcn8s</code>文件夹</p>
</li>
<li><p>运行<code>python net.py</code>生成训练的<code>trainval.prototxt</code>和测试的<code>test.prototxt</code></p>
</li>
<li><p>运行<code>solve.py</code>训练网络, 大约需要十八个小时左右(NVIDIA K40m)</p>
</li>
</ol>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 2016-12-02 04:36:48.858090 Iteration 100000 loss 31759.9664818</span><br><span class="line">&gt;&gt;&gt; 2016-12-02 04:36:48.858175 Iteration 100000 overall accuracy 0.945324129081</span><br><span class="line">&gt;&gt;&gt; 2016-12-02 04:36:48.858204 Iteration 100000 mean accuracy 0.94380113626</span><br><span class="line">&gt;&gt;&gt; 2016-12-02 04:36:48.858371 Iteration 100000 mean IU 0.891361831963</span><br><span class="line">&gt;&gt;&gt; 2016-12-02 04:36:48.858443 Iteration 100000 fwavacc 0.896517250126</span><br></pre></td></tr></table></figure>
<ul>
<li>和论文结果相差零点几个百分点, demo训练成功, 下面我们要基于该网络做</li>
</ul>
<h3 id="Python-Layer"><a href="#Python-Layer" class="headerlink" title="Python Layer"></a><strong>Python Layer</strong></h3><p><strong>数据制作问题:</strong></p>
<p>caffe的label必须是从自然数N连续的开始的。0，1，2，…，N，这就表示了具有N+1个类别的标签label。</p>
<p>Caffe通过Boost中的<code>Boost.Python</code>模块来支持使用Python定义Layer</p>
<ul>
<li><p>使用C++增加新的Layer繁琐耗时</p>
</li>
<li><p>开发速度与执行速度之间的权衡</p>
</li>
</ul>
<p>在网络的输入层可以使用python自己加载数据, 但是在编译caffe的时候要将Makefile.config文件中的<code>WITH_PYTHON_LAYER := 1</code>注释掉, 在用<code>net.py</code>生成的trainval.prototxt中定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">layer &#123;</span><br><span class="line">  name: &quot;data&quot;</span><br><span class="line">  type: &quot;Python&quot;</span><br><span class="line">  top: &quot;data&quot;</span><br><span class="line">  top: &quot;sem&quot;</span><br><span class="line">  top: &quot;geo&quot;</span><br><span class="line">  python_param &#123;</span><br><span class="line">    module: &quot;siftflow_layers&quot;</span><br><span class="line">    layer: &quot;SIFTFlowSegDataLayer&quot;</span><br><span class="line">    param_str: &quot;&#123;\&apos;siftflow_dir\&apos;: \&apos;../data/sift-flow\&apos;, \&apos;seed\&apos;: 1337, \&apos;split\&apos;: \&apos;trainval\&apos;&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>module</code>的名字，通常是定义Layer的.py文件的文件名，需要在$PYTHONPATH下</li>
<li><code>layer</code>是定义的类的名字</li>
</ul>
<p>SIFTFlowSegDataLayer在<strong>siftflow_layers.py</strong>的文件中被定义为一个类:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> caffe</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> scipy.io</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SIFTFlowSegDataLayer</span><span class="params">(caffe.Layer)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Load (input image, label image) pairs from SIFT Flow</span></span><br><span class="line"><span class="string">    one-at-a-time while reshaping the net to preserve dimensions.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This data layer has three tops:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    1. the data, pre-processed</span></span><br><span class="line"><span class="string">    2. the semantic labels 0-32 and void 255</span></span><br><span class="line"><span class="string">    3. the geometric labels 0-2 and void 255</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Use this to feed data to a fully convolutional network.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(self, bottom, top)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Setup data layer according to parameters:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        - siftflow_dir: path to SIFT Flow dir</span></span><br><span class="line"><span class="string">        - split: train / val / test</span></span><br><span class="line"><span class="string">        - randomize: load in random order (default: True)</span></span><br><span class="line"><span class="string">        - seed: seed for randomization (default: None / current time)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        for semantic segmentation of object and geometric classes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        example: params = dict(siftflow_dir="/path/to/siftflow", split="val")</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># config</span></span><br><span class="line">        params = eval(self.param_str)</span><br><span class="line">        self.siftflow_dir = params[<span class="string">'siftflow_dir'</span>]</span><br><span class="line">        self.split = params[<span class="string">'split'</span>]</span><br><span class="line">        self.mean = np.array((<span class="number">114.578</span>, <span class="number">115.294</span>, <span class="number">108.353</span>), dtype=np.float32)</span><br><span class="line">        self.random = params.get(<span class="string">'randomize'</span>, <span class="keyword">True</span>)</span><br><span class="line">        self.seed = params.get(<span class="string">'seed'</span>, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># three tops: data, semantic, geometric</span></span><br><span class="line">        <span class="keyword">if</span> len(top) != <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Need to define three tops: data, semantic label, and geometric label."</span>)</span><br><span class="line">        <span class="comment"># data layers have no bottoms</span></span><br><span class="line">        <span class="keyword">if</span> len(bottom) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Do not define a bottom."</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># load indices for images and labels</span></span><br><span class="line">        split_f  = <span class="string">'&#123;&#125;/&#123;&#125;.txt'</span>.format(self.siftflow_dir, self.split)</span><br><span class="line">        self.indices = open(split_f, <span class="string">'r'</span>).read().splitlines()</span><br><span class="line">        self.idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># make eval deterministic</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'train'</span> <span class="keyword">not</span> <span class="keyword">in</span> self.split:</span><br><span class="line">            self.random = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># randomization: seed and pick</span></span><br><span class="line">        <span class="keyword">if</span> self.random:</span><br><span class="line">            random.seed(self.seed)</span><br><span class="line">            self.idx = random.randint(<span class="number">0</span>, len(self.indices)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reshape</span><span class="params">(self, bottom, top)</span>:</span></span><br><span class="line">        <span class="comment"># load image + label image pair</span></span><br><span class="line">        self.data = self.load_image(self.indices[self.idx])</span><br><span class="line">        self.label_semantic = self.load_label(self.indices[self.idx], label_type=<span class="string">'semantic'</span>)</span><br><span class="line">        self.label_geometric = self.load_label(self.indices[self.idx], label_type=<span class="string">'geometric'</span>)</span><br><span class="line">        <span class="comment"># reshape tops to fit (leading 1 is for batch dimension)</span></span><br><span class="line">        top[<span class="number">0</span>].reshape(<span class="number">1</span>, *self.data.shape)</span><br><span class="line">        top[<span class="number">1</span>].reshape(<span class="number">1</span>, *self.label_semantic.shape)</span><br><span class="line">        top[<span class="number">2</span>].reshape(<span class="number">1</span>, *self.label_geometric.shape)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, bottom, top)</span>:</span></span><br><span class="line">        <span class="comment"># assign output</span></span><br><span class="line">        top[<span class="number">0</span>].data[...] = self.data</span><br><span class="line">        top[<span class="number">1</span>].data[...] = self.label_semantic</span><br><span class="line">        top[<span class="number">2</span>].data[...] = self.label_geometric</span><br><span class="line"></span><br><span class="line">        <span class="comment"># pick next input</span></span><br><span class="line">        <span class="keyword">if</span> self.random:</span><br><span class="line">            self.idx = random.randint(<span class="number">0</span>, len(self.indices)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.idx == len(self.indices):</span><br><span class="line">                self.idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(self, top, propagate_down, bottom)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_image</span><span class="params">(self, idx)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Load input image and preprocess for Caffe:</span></span><br><span class="line"><span class="string">        - cast to float</span></span><br><span class="line"><span class="string">        - switch channels RGB -&gt; BGR</span></span><br><span class="line"><span class="string">        - subtract mean</span></span><br><span class="line"><span class="string">        - transpose to channel x height x width order</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        im = Image.open(<span class="string">'&#123;&#125;/Images/&#123;&#125;.jpg'</span>.format(self.siftflow_dir, idx))</span><br><span class="line">        in_ = np.array(im, dtype=np.float32)</span><br><span class="line">        in_ = in_[:,:,::<span class="number">-1</span>]</span><br><span class="line">        in_ -= self.mean</span><br><span class="line">        in_ = in_.transpose((<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> in_</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_label</span><span class="params">(self, idx, label_type=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Load label image as 1 x height x width integer array of label indices.</span></span><br><span class="line"><span class="string">        The leading singleton dimension is required by the loss.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> label_type == <span class="string">'semantic'</span>:</span><br><span class="line">            label = scipy.io.loadmat(<span class="string">'&#123;&#125;/SemanticLabels/&#123;&#125;.mat'</span>.format(self.siftflow_dir, idx))[<span class="string">'S'</span>]</span><br><span class="line">        <span class="keyword">elif</span> label_type == <span class="string">'geometric'</span>:</span><br><span class="line">            label = scipy.io.loadmat(<span class="string">'&#123;&#125;/GeoLabels/&#123;&#125;.mat'</span>.format(self.siftflow_dir, idx))[<span class="string">'S'</span>]</span><br><span class="line">            label[label == <span class="number">-1</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Unknown label type: &#123;&#125;. Pick semantic or geometric."</span>.format(label_type))</span><br><span class="line">        label = label.astype(np.uint8)</span><br><span class="line">        label -= <span class="number">1</span>  <span class="comment"># rotate labels so classes start at 0, void is 255</span></span><br><span class="line">        label = label[np.newaxis, ...]</span><br><span class="line">        <span class="keyword">return</span> label.copy()</span><br></pre></td></tr></table></figure>
<ul>
<li>在定义layer的python文件中, 类的名称就是在prototxt中<code>参数layer</code>的名称</li>
<li>类直接继承的是<code>caffe.Layer</code>，然后必须重写<code>setup()</code>，<code>reshape()</code>，<code>forward()</code>，<code>backward()</code>函数，在该类中也可以定义其他函数</li>
<li><code>setup()</code>是类启动时该层所需数据的初始化等操作</li>
<li><code>reshape()</code>是读取数据然后规范化为四维的矩阵</li>
<li><code>forward()</code>是网络的前向运算，这里就是把取到的数据往前传递，因为data层没有其他运算</li>
<li><code>backward()</code>就是网络的后向求导，data层是没有反馈的就直接pass</li>
</ul>
<blockquote>
<p>了解如何在C++中创建新的layer : <a href="http://chrischoy.github.io/research/making-caffe-layer/" target="_blank" rel="noopener">Making a Caffe Layer</a></p>
</blockquote>
<h3 id="构建网络"><a href="#构建网络" class="headerlink" title="构建网络"></a><strong>构建网络</strong></h3><p>构建网络网络本质上就是生成训练和测试的<code>.prototxt文件</code>, 在这里直接用<code>net.py</code>定义网络结构, 运行该python文件就可以生成相应的<code>prototxt文件</code>, 网络所有参数在net中定义</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> caffe</span><br><span class="line"><span class="keyword">from</span> caffe <span class="keyword">import</span> layers <span class="keyword">as</span> L, params <span class="keyword">as</span> P</span><br><span class="line"><span class="keyword">from</span> coord_map <span class="keyword">import</span> crop</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_relu</span><span class="params">(bottom, nout, ks=<span class="number">3</span>, stride=<span class="number">1</span>, pad=<span class="number">1</span>)</span>:</span></span><br><span class="line">    conv = L.Convolution(bottom, kernel_size=ks, stride=stride,</span><br><span class="line">        num_output=nout, pad=pad,</span><br><span class="line">        param=[dict(lr_mult=<span class="number">1</span>, decay_mult=<span class="number">1</span>), dict(lr_mult=<span class="number">2</span>, decay_mult=<span class="number">0</span>)])</span><br><span class="line">    <span class="keyword">return</span> conv, L.ReLU(conv, in_place=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_pool</span><span class="params">(bottom, ks=<span class="number">2</span>, stride=<span class="number">2</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> L.Pooling(bottom, pool=P.Pooling.MAX, kernel_size=ks, stride=stride)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fcn</span><span class="params">(split)</span>:</span></span><br><span class="line">    n = caffe.NetSpec()</span><br><span class="line">    n.data, n.sem, n.geo = L.Python(module=<span class="string">'siftflow_layers'</span>,</span><br><span class="line">            layer=<span class="string">'SIFTFlowSegDataLayer'</span>, ntop=<span class="number">3</span>,</span><br><span class="line">            param_str=str(dict(siftflow_dir=<span class="string">'../data/sift-flow'</span>,</span><br><span class="line">                split=split, seed=<span class="number">1337</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># the base net</span></span><br><span class="line">    n.conv1_1, n.relu1_1 = conv_relu(n.data, <span class="number">64</span>, pad=<span class="number">100</span>)</span><br><span class="line">    n.conv1_2, n.relu1_2 = conv_relu(n.relu1_1, <span class="number">64</span>)</span><br><span class="line">    n.pool1 = max_pool(n.relu1_2)</span><br><span class="line"></span><br><span class="line">    n.conv2_1, n.relu2_1 = conv_relu(n.pool1, <span class="number">128</span>)</span><br><span class="line">    n.conv2_2, n.relu2_2 = conv_relu(n.relu2_1, <span class="number">128</span>)</span><br><span class="line">    n.pool2 = max_pool(n.relu2_2)</span><br><span class="line"></span><br><span class="line">    n.conv3_1, n.relu3_1 = conv_relu(n.pool2, <span class="number">256</span>)</span><br><span class="line">    n.conv3_2, n.relu3_2 = conv_relu(n.relu3_1, <span class="number">256</span>)</span><br><span class="line">    n.conv3_3, n.relu3_3 = conv_relu(n.relu3_2, <span class="number">256</span>)</span><br><span class="line">    n.pool3 = max_pool(n.relu3_3)</span><br><span class="line"></span><br><span class="line">    n.conv4_1, n.relu4_1 = conv_relu(n.pool3, <span class="number">512</span>)</span><br><span class="line">    n.conv4_2, n.relu4_2 = conv_relu(n.relu4_1, <span class="number">512</span>)</span><br><span class="line">    n.conv4_3, n.relu4_3 = conv_relu(n.relu4_2, <span class="number">512</span>)</span><br><span class="line">    n.pool4 = max_pool(n.relu4_3)</span><br><span class="line"></span><br><span class="line">    n.conv5_1, n.relu5_1 = conv_relu(n.pool4, <span class="number">512</span>)</span><br><span class="line">    n.conv5_2, n.relu5_2 = conv_relu(n.relu5_1, <span class="number">512</span>)</span><br><span class="line">    n.conv5_3, n.relu5_3 = conv_relu(n.relu5_2, <span class="number">512</span>)</span><br><span class="line">    n.pool5 = max_pool(n.relu5_3)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># fully conv</span></span><br><span class="line">    n.fc6, n.relu6 = conv_relu(n.pool5, <span class="number">4096</span>, ks=<span class="number">7</span>, pad=<span class="number">0</span>)</span><br><span class="line">    n.drop6 = L.Dropout(n.relu6, dropout_ratio=<span class="number">0.5</span>, in_place=<span class="keyword">True</span>)</span><br><span class="line">    n.fc7, n.relu7 = conv_relu(n.drop6, <span class="number">4096</span>, ks=<span class="number">1</span>, pad=<span class="number">0</span>)</span><br><span class="line">    n.drop7 = L.Dropout(n.relu7, dropout_ratio=<span class="number">0.5</span>, in_place=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    n.score_fr_sem = L.Convolution(n.drop7, num_output=<span class="number">110</span>, kernel_size=<span class="number">1</span>, pad=<span class="number">0</span>,</span><br><span class="line">        param=[dict(lr_mult=<span class="number">1</span>, decay_mult=<span class="number">1</span>), dict(lr_mult=<span class="number">2</span>, decay_mult=<span class="number">0</span>)])</span><br><span class="line">    n.upscore2_sem = L.Deconvolution(n.score_fr_sem,</span><br><span class="line">        convolution_param=dict(num_output=<span class="number">110</span>, kernel_size=<span class="number">4</span>, stride=<span class="number">2</span>,</span><br><span class="line">            bias_term=<span class="keyword">False</span>),</span><br><span class="line">        param=[dict(lr_mult=<span class="number">0</span>)])</span><br><span class="line"></span><br><span class="line">    n.score_pool4_sem = L.Convolution(n.pool4, num_output=<span class="number">110</span>, kernel_size=<span class="number">1</span>, pad=<span class="number">0</span>,</span><br><span class="line">        param=[dict(lr_mult=<span class="number">1</span>, decay_mult=<span class="number">1</span>), dict(lr_mult=<span class="number">2</span>, decay_mult=<span class="number">0</span>)])</span><br><span class="line">    n.score_pool4_semc = crop(n.score_pool4_sem, n.upscore2_sem)</span><br><span class="line">    n.fuse_pool4_sem = L.Eltwise(n.upscore2_sem, n.score_pool4_semc,</span><br><span class="line">            operation=P.Eltwise.SUM)</span><br><span class="line">    n.upscore_pool4_sem  = L.Deconvolution(n.fuse_pool4_sem,</span><br><span class="line">        convolution_param=dict(num_output=<span class="number">110</span>, kernel_size=<span class="number">4</span>, stride=<span class="number">2</span>,</span><br><span class="line">            bias_term=<span class="keyword">False</span>),</span><br><span class="line">        param=[dict(lr_mult=<span class="number">0</span>)])</span><br><span class="line"></span><br><span class="line">    n.score_pool3_sem = L.Convolution(n.pool3, num_output=<span class="number">110</span>, kernel_size=<span class="number">1</span>,</span><br><span class="line">            pad=<span class="number">0</span>, param=[dict(lr_mult=<span class="number">1</span>, decay_mult=<span class="number">1</span>), dict(lr_mult=<span class="number">2</span>,</span><br><span class="line">                decay_mult=<span class="number">0</span>)])</span><br><span class="line">    n.score_pool3_semc = crop(n.score_pool3_sem, n.upscore_pool4_sem)</span><br><span class="line">    n.fuse_pool3_sem = L.Eltwise(n.upscore_pool4_sem, n.score_pool3_semc,</span><br><span class="line">            operation=P.Eltwise.SUM)</span><br><span class="line">    n.upscore8_sem = L.Deconvolution(n.fuse_pool3_sem,</span><br><span class="line">        convolution_param=dict(num_output=<span class="number">110</span>, kernel_size=<span class="number">16</span>, stride=<span class="number">8</span>,</span><br><span class="line">            bias_term=<span class="keyword">False</span>),</span><br><span class="line">        param=[dict(lr_mult=<span class="number">0</span>)])</span><br><span class="line"></span><br><span class="line">    n.score_sem = crop(n.upscore8_sem, n.data)</span><br><span class="line">    <span class="comment"># loss to make score happy (o.w. loss_sem)</span></span><br><span class="line">    n.loss = L.SoftmaxWithLoss(n.score_sem, n.sem,</span><br><span class="line">            loss_param=dict(normalize=<span class="keyword">False</span>, ignore_label=<span class="number">255</span>))</span><br><span class="line"></span><br><span class="line">    n.score_fr_geo = L.Convolution(n.drop7, num_output=<span class="number">1</span>, kernel_size=<span class="number">1</span>, pad=<span class="number">0</span>,</span><br><span class="line">        param=[dict(lr_mult=<span class="number">1</span>, decay_mult=<span class="number">1</span>), dict(lr_mult=<span class="number">2</span>, decay_mult=<span class="number">0</span>)])</span><br><span class="line"></span><br><span class="line">    n.upscore2_geo = L.Deconvolution(n.score_fr_geo,</span><br><span class="line">        convolution_param=dict(num_output=<span class="number">1</span>, kernel_size=<span class="number">4</span>, stride=<span class="number">2</span>,</span><br><span class="line">            bias_term=<span class="keyword">False</span>),</span><br><span class="line">        param=[dict(lr_mult=<span class="number">0</span>)])</span><br><span class="line"></span><br><span class="line">    n.score_pool4_geo = L.Convolution(n.pool4, num_output=<span class="number">1</span>, kernel_size=<span class="number">1</span>, pad=<span class="number">0</span>,</span><br><span class="line">        param=[dict(lr_mult=<span class="number">1</span>, decay_mult=<span class="number">1</span>), dict(lr_mult=<span class="number">2</span>, decay_mult=<span class="number">0</span>)])</span><br><span class="line">    n.score_pool4_geoc = crop(n.score_pool4_geo, n.upscore2_geo)</span><br><span class="line">    n.fuse_pool4_geo = L.Eltwise(n.upscore2_geo, n.score_pool4_geoc,</span><br><span class="line">            operation=P.Eltwise.SUM)</span><br><span class="line">    n.upscore_pool4_geo  = L.Deconvolution(n.fuse_pool4_geo,</span><br><span class="line">        convolution_param=dict(num_output=<span class="number">1</span>, kernel_size=<span class="number">4</span>, stride=<span class="number">2</span>,</span><br><span class="line">            bias_term=<span class="keyword">False</span>),</span><br><span class="line">        param=[dict(lr_mult=<span class="number">0</span>)])</span><br><span class="line"></span><br><span class="line">    n.score_pool3_geo = L.Convolution(n.pool3, num_output=<span class="number">1</span>, kernel_size=<span class="number">1</span>,</span><br><span class="line">            pad=<span class="number">0</span>, param=[dict(lr_mult=<span class="number">1</span>, decay_mult=<span class="number">1</span>), dict(lr_mult=<span class="number">2</span>,</span><br><span class="line">                decay_mult=<span class="number">0</span>)])</span><br><span class="line">    n.score_pool3_geoc = crop(n.score_pool3_geo, n.upscore_pool4_geo)</span><br><span class="line">    n.fuse_pool3_geo = L.Eltwise(n.upscore_pool4_geo, n.score_pool3_geoc,</span><br><span class="line">            operation=P.Eltwise.SUM)</span><br><span class="line">    n.upscore8_geo = L.Deconvolution(n.fuse_pool3_geo,</span><br><span class="line">        convolution_param=dict(num_output=<span class="number">1</span>, kernel_size=<span class="number">16</span>, stride=<span class="number">8</span>,</span><br><span class="line">            bias_term=<span class="keyword">False</span>),</span><br><span class="line">        param=[dict(lr_mult=<span class="number">0</span>)])</span><br><span class="line"></span><br><span class="line">    n.score_geo = crop(n.upscore8_geo, n.data)</span><br><span class="line">    n.loss_geo = L.SoftmaxWithLoss(n.score_geo, n.geo,</span><br><span class="line">            loss_param=dict(normalize=<span class="keyword">False</span>, ignore_label=<span class="number">255</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n.to_proto()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_net</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'trainval.prototxt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(str(fcn(<span class="string">'trainval'</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'test.prototxt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(str(fcn(<span class="string">'test'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    make_net()</span><br></pre></td></tr></table></figure>
<ul>
<li>注意在<code>Fine-tuning</code>(微调)一个网络的时候, 由于<code>output_num</code>已经改变, 要将所有含有<code>output_num</code>发生改变的层重命名, 原因是在我们下载的caffemodel中已经包含原有的层名称, 而在<code>.prototxt</code>中我们更改了输出参数, 在加载caffemodel时, 如果层名称一样但是数据结构不同, 就会报错, 重命名之后模型中原有的层会被忽略继而使用我们自己定义的新的层</li>
</ul>
<h3 id="solver-prototxt"><a href="#solver-prototxt" class="headerlink" title="solver.prototxt"></a><strong>solver.prototxt</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">train_net: &quot;trainval.prototxt&quot;</span><br><span class="line">test_net: &quot;test.prototxt&quot;</span><br><span class="line">test_iter: 1000</span><br><span class="line"># make test net, but don&apos;t invoke it from the solver itself</span><br><span class="line">test_interval: 999999999</span><br><span class="line">display: 100</span><br><span class="line">average_loss: 100</span><br><span class="line">lr_policy: &quot;fixed&quot;</span><br><span class="line"># lr for unnormalized softmax</span><br><span class="line">base_lr: 1e-12</span><br><span class="line"># high momentum</span><br><span class="line">momentum: 0.99</span><br><span class="line"># no gradient accumulation</span><br><span class="line">iter_size: 1</span><br><span class="line">max_iter: 300000</span><br><span class="line">weight_decay: 0.0005</span><br><span class="line">test_initialization: false</span><br></pre></td></tr></table></figure>
<p><strong>如何更改FCN的batch size?</strong></p>
<ul>
<li>最简单的方式是更改<code>iter_size</code>参数, 在文中<code>iter_size: 1</code>$, 也就是说每次迭代输入一个样本, 即batch_size=1</li>
</ul>
<p><code>test_iter: 1000</code> : 由于我们的batchsize=1, 测试样本数为1000, 需要迭代1000次才能完成</p>
<h2 id="Pascal-Context"><a href="#Pascal-Context" class="headerlink" title="Pascal-Context"></a><strong>Pascal-Context</strong></h2><blockquote>
<p>数据的准备和设置就不多说了在Github的README上都有, 主要有三个方面:</p>
</blockquote>
<ol>
<li>JPEG原始图片</li>
<li>mat文件的label</li>
<li>下载caffemodel</li>
</ol>
<p>然后在相应的python文件中设置路径就可以了</p>
<h3 id="网络结构-1"><a href="#网络结构-1" class="headerlink" title="网络结构"></a><strong>网络结构</strong></h3><p>通过更改net.py生成了111类(包括背景类)的分类模型, 运行<code>net.py</code>可以生成<code>train.prototxt</code>和<code>val.prototxt</code>, 网络结构如下:</p>
<p><img src="/img/FCN-in-Caffe/pascal-fcn8s.png" alt=""></p>
<h3 id="Python-Layer-1"><a href="#Python-Layer-1" class="headerlink" title="Python Layer"></a><strong>Python Layer</strong></h3><p>Pascal-Context的Python Layer定义如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> caffe</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> scipy.io</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PASCALContextSegDataLayer</span><span class="params">(caffe.Layer)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Load (input image, label image) pairs from PASCAL-Context</span></span><br><span class="line"><span class="string">    one-at-a-time while reshaping the net to preserve dimensions.</span></span><br><span class="line"><span class="string">    The labels follow the 59 class task defined by</span></span><br><span class="line"><span class="string">        R. Mottaghi, X. Chen, X. Liu, N.-G. Cho, S.-W. Lee, S. Fidler, R.</span></span><br><span class="line"><span class="string">        Urtasun, and A. Yuille.  The Role of Context for Object Detection and</span></span><br><span class="line"><span class="string">        Semantic Segmentation in the Wild.  CVPR 2014.</span></span><br><span class="line"><span class="string">    Use this to feed data to a fully convolutional network.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(self, bottom, top)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Setup data layer according to parameters:</span></span><br><span class="line"><span class="string">        - voc_dir: path to PASCAL VOC dir (must contain 2010)</span></span><br><span class="line"><span class="string">        - context_dir: path to PASCAL-Context annotations</span></span><br><span class="line"><span class="string">        - split: train / val / test</span></span><br><span class="line"><span class="string">        - randomize: load in random order (default: True)</span></span><br><span class="line"><span class="string">        - seed: seed for randomization (default: None / current time)</span></span><br><span class="line"><span class="string">        for PASCAL-Context semantic segmentation.</span></span><br><span class="line"><span class="string">        example: params = dict(voc_dir="/path/to/PASCAL", split="val")</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># config</span></span><br><span class="line">        params = eval(self.param_str)</span><br><span class="line">        self.voc_dir = params[<span class="string">'voc_dir'</span>] + <span class="string">'/VOC2010'</span></span><br><span class="line">        self.context_dir = params[<span class="string">'context_dir'</span>]</span><br><span class="line">        self.split = params[<span class="string">'split'</span>]</span><br><span class="line">        self.mean = np.array((<span class="number">104.007</span>, <span class="number">116.669</span>, <span class="number">122.679</span>), dtype=np.float32)</span><br><span class="line">        self.random = params.get(<span class="string">'randomize'</span>, <span class="keyword">True</span>)</span><br><span class="line">        self.seed = params.get(<span class="string">'seed'</span>, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># load labels and resolve inconsistencies by mapping to full 400 labels</span></span><br><span class="line">        self.labels_400 = [label.replace(<span class="string">' '</span>,<span class="string">''</span>) <span class="keyword">for</span> idx, label <span class="keyword">in</span> np.genfromtxt(self.context_dir + <span class="string">'/labels.txt'</span>, delimiter=<span class="string">':'</span>, dtype=<span class="keyword">None</span>)]</span><br><span class="line">        self.labels_59 = [label.replace(<span class="string">' '</span>,<span class="string">''</span>) <span class="keyword">for</span> idx, label <span class="keyword">in</span> np.genfromtxt(self.context_dir + <span class="string">'/59_labels.txt'</span>, delimiter=<span class="string">':'</span>, dtype=<span class="keyword">None</span>)]</span><br><span class="line">        <span class="keyword">for</span> main_label, task_label <span class="keyword">in</span> zip((<span class="string">'table'</span>, <span class="string">'bedclothes'</span>, <span class="string">'cloth'</span>), (<span class="string">'diningtable'</span>, <span class="string">'bedcloth'</span>, <span class="string">'clothes'</span>)):</span><br><span class="line">            self.labels_59[self.labels_59.index(task_label)] = main_label</span><br><span class="line"></span><br><span class="line">        <span class="comment"># two tops: data and label</span></span><br><span class="line">        <span class="keyword">if</span> len(top) != <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Need to define two tops: data and label."</span>)</span><br><span class="line">        <span class="comment"># data layers have no bottoms</span></span><br><span class="line">        <span class="keyword">if</span> len(bottom) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Do not define a bottom."</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># load indices for images and labels</span></span><br><span class="line">        split_f  = <span class="string">'&#123;&#125;/ImageSets/Main/&#123;&#125;.txt'</span>.format(self.voc_dir,</span><br><span class="line">                self.split)</span><br><span class="line">        self.indices = open(split_f, <span class="string">'r'</span>).read().splitlines()</span><br><span class="line">        self.idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># make eval deterministic</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'train'</span> <span class="keyword">not</span> <span class="keyword">in</span> self.split:</span><br><span class="line">            self.random = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># randomization: seed and pick</span></span><br><span class="line">        <span class="keyword">if</span> self.random:</span><br><span class="line">            random.seed(self.seed)</span><br><span class="line">            self.idx = random.randint(<span class="number">0</span>, len(self.indices)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reshape</span><span class="params">(self, bottom, top)</span>:</span></span><br><span class="line">        <span class="comment"># load image + label image pair</span></span><br><span class="line">        self.data = self.load_image(self.indices[self.idx])</span><br><span class="line">        self.label = self.load_label(self.indices[self.idx])</span><br><span class="line">        <span class="comment"># reshape tops to fit (leading 1 is for batch dimension)</span></span><br><span class="line">        top[<span class="number">0</span>].reshape(<span class="number">1</span>, *self.data.shape)</span><br><span class="line">        top[<span class="number">1</span>].reshape(<span class="number">1</span>, *self.label.shape)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, bottom, top)</span>:</span></span><br><span class="line">        <span class="comment"># assign output</span></span><br><span class="line">        top[<span class="number">0</span>].data[...] = self.data</span><br><span class="line">        top[<span class="number">1</span>].data[...] = self.label</span><br><span class="line"></span><br><span class="line">        <span class="comment"># pick next input</span></span><br><span class="line">        <span class="keyword">if</span> self.random:</span><br><span class="line">            self.idx = random.randint(<span class="number">0</span>, len(self.indices)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.idx == len(self.indices):</span><br><span class="line">                self.idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(self, top, propagate_down, bottom)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_image</span><span class="params">(self, idx)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Load input image and preprocess for Caffe:</span></span><br><span class="line"><span class="string">        - cast to float</span></span><br><span class="line"><span class="string">        - switch channels RGB -&gt; BGR</span></span><br><span class="line"><span class="string">        - subtract mean</span></span><br><span class="line"><span class="string">        - transpose to channel x height x width order</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        im = Image.open(<span class="string">'&#123;&#125;/JPEGImages/&#123;&#125;.jpg'</span>.format(self.voc_dir, idx))</span><br><span class="line">        in_ = np.array(im, dtype=np.float32)</span><br><span class="line">        in_ = in_[:,:,::<span class="number">-1</span>]</span><br><span class="line">        in_ -= self.mean</span><br><span class="line">        in_ = in_.transpose((<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> in_</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_label</span><span class="params">(self, idx)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Load label image as 1 x height x width integer array of label indices.</span></span><br><span class="line"><span class="string">        The leading singleton dimension is required by the loss.</span></span><br><span class="line"><span class="string">        The full 400 labels are translated to the 59 class task labels.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        label_400 = scipy.io.loadmat(<span class="string">'&#123;&#125;/trainval/&#123;&#125;.mat'</span>.format(self.context_dir, idx))[<span class="string">'LabelMap'</span>]</span><br><span class="line">        label = np.zeros_like(label_400, dtype=np.uint8)</span><br><span class="line">        <span class="keyword">for</span> idx, l <span class="keyword">in</span> enumerate(self.labels_59):</span><br><span class="line">            idx_400 = self.labels_400.index(l) + <span class="number">1</span></span><br><span class="line">            label[label_400 == idx_400] = idx + <span class="number">1</span></span><br><span class="line">        label = label[np.newaxis, ...]</span><br><span class="line">        <span class="keyword">return</span> label</span><br></pre></td></tr></table></figure>
<p>值得注意的是在Python Layer中对于label的处理方式, 我们将源代码中的对于label的处理程序抽取出来:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.io</span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">'voc_dir'</span>: <span class="string">'./data/pascal'</span>,</span><br><span class="line">    <span class="string">'context_dir'</span>: <span class="string">'./data/pascal-context'</span>,</span><br><span class="line">    <span class="string">'split'</span>: <span class="string">'train'</span>,</span><br><span class="line">    <span class="string">'seed'</span>: <span class="number">1337</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">voc_dir = params[<span class="string">'voc_dir'</span>] + <span class="string">'/VOC2010'</span></span><br><span class="line">context_dir = params[<span class="string">'context_dir'</span>]</span><br><span class="line">split = params[<span class="string">'split'</span>]</span><br><span class="line">mean = np.array((<span class="number">104.007</span>, <span class="number">116.669</span>, <span class="number">122.679</span>), dtype=np.float32)</span><br><span class="line">random = params.get(<span class="string">'randomize'</span>, <span class="keyword">True</span>)</span><br><span class="line">seed = params.get(<span class="string">'seed'</span>, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># load labels and resolve inconsistencies by mapping to full 400 labels</span></span><br><span class="line">labels_400 = [label.replace(<span class="string">' '</span>,<span class="string">''</span>) <span class="keyword">for</span> idx, label <span class="keyword">in</span> np.genfromtxt(context_dir + <span class="string">'/labels.txt'</span>, delimiter=<span class="string">':'</span>, dtype=<span class="keyword">None</span>)]</span><br><span class="line"><span class="keyword">print</span> labels_400</span><br><span class="line">labels_59 = [label.replace(<span class="string">' '</span>,<span class="string">''</span>) <span class="keyword">for</span> idx, label <span class="keyword">in</span> np.genfromtxt(context_dir + <span class="string">'/59_labels.txt'</span>, delimiter=<span class="string">':'</span>, dtype=<span class="keyword">None</span>)]</span><br><span class="line"><span class="keyword">print</span> labels_59</span><br><span class="line"><span class="keyword">for</span> main_label, task_label <span class="keyword">in</span> zip((<span class="string">'table'</span>, <span class="string">'bedclothes'</span>, <span class="string">'cloth'</span>), (<span class="string">'diningtable'</span>, <span class="string">'bedcloth'</span>, <span class="string">'clothes'</span>)):</span><br><span class="line">    labels_59[labels_59.index(task_label)] = main_label</span><br><span class="line"><span class="keyword">print</span> labels_59</span><br><span class="line"><span class="comment"># load indices for images and labels</span></span><br><span class="line">split_f  = <span class="string">'&#123;&#125;/ImageSets/Main/&#123;&#125;.txt'</span>.format(voc_dir,split)</span><br><span class="line">indices = open(split_f, <span class="string">'r'</span>).read().splitlines()</span><br><span class="line">idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># make eval deterministic</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">'train'</span> <span class="keyword">not</span> <span class="keyword">in</span> split:</span><br><span class="line">    random = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Load label image as 1 x height x width integer array of label indices.</span></span><br><span class="line"><span class="string">The leading singleton dimension is required by the loss.</span></span><br><span class="line"><span class="string">The full 400 labels are translated to the 59 class task labels.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">label_400 = scipy.io.loadmat(<span class="string">'&#123;&#125;/trainval/&#123;&#125;.mat'</span>.format(context_dir, indices[idx]))[<span class="string">'LabelMap'</span>]</span><br><span class="line"><span class="keyword">print</span> indices[idx]</span><br><span class="line"><span class="keyword">print</span> label_400</span><br><span class="line">label = np.zeros_like(label_400, dtype=np.uint8)</span><br><span class="line"><span class="keyword">print</span> label</span><br><span class="line"><span class="keyword">for</span> idx, l <span class="keyword">in</span> enumerate(labels_59):</span><br><span class="line">    idx_400 = labels_400.index(l) + <span class="number">1</span></span><br><span class="line">    label[label_400 == idx_400] = idx + <span class="number">1</span></span><br><span class="line">label = label[np.newaxis, ...]</span><br><span class="line"><span class="keyword">print</span> label</span><br></pre></td></tr></table></figure>
<ul>
<li>通过打印输出可以得出结论: 将459类映射为59类的标签数据, 所以在制作自己的数据集的label的时候直接返回自己的标签就可以了, 不用这些处理, 更改后的net.py文件如下: 仅供参考</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> caffe</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> scipy.io</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PASCALContextSegDataLayer</span><span class="params">(caffe.Layer)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(self, bottom, top)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># config</span></span><br><span class="line">        params = eval(self.param_str)</span><br><span class="line">        self.voc_dir = params[<span class="string">'voc_dir'</span>]</span><br><span class="line">        self.context_dir = params[<span class="string">'context_dir'</span>]</span><br><span class="line">        self.split = params[<span class="string">'split'</span>]</span><br><span class="line">        self.mean = np.array((<span class="number">104.007</span>, <span class="number">116.669</span>, <span class="number">122.679</span>), dtype=np.float32)</span><br><span class="line">        self.random = params.get(<span class="string">'randomize'</span>, <span class="keyword">True</span>)</span><br><span class="line">        self.seed = params.get(<span class="string">'seed'</span>, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># load labels and resolve inconsistencies by mapping to full 111 labels</span></span><br><span class="line">        self.labels_111 = [label.replace(<span class="string">' '</span>,<span class="string">''</span>) <span class="keyword">for</span> idx, label <span class="keyword">in</span> np.genfromtxt(self.context_dir + <span class="string">'/labels.txt'</span>, delimiter=<span class="string">':'</span>, dtype=<span class="keyword">None</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># two tops: data and label</span></span><br><span class="line">        <span class="keyword">if</span> len(top) != <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Need to define two tops: data and label."</span>)</span><br><span class="line">        <span class="comment"># data layers have no bottoms</span></span><br><span class="line">        <span class="keyword">if</span> len(bottom) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Do not define a bottom."</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># load indices for images and labels</span></span><br><span class="line">        split_f  = <span class="string">'&#123;&#125;/ImageSets/Main/&#123;&#125;.txt'</span>.format(self.voc_dir,</span><br><span class="line">                self.split)</span><br><span class="line">        self.indices = open(split_f, <span class="string">'r'</span>).read().splitlines()</span><br><span class="line">        self.idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># make eval deterministic</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'train'</span> <span class="keyword">not</span> <span class="keyword">in</span> self.split:</span><br><span class="line">            self.random = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># randomization: seed and pick</span></span><br><span class="line">        <span class="keyword">if</span> self.random:</span><br><span class="line">            random.seed(self.seed)</span><br><span class="line">            self.idx = random.randint(<span class="number">0</span>, len(self.indices)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reshape</span><span class="params">(self, bottom, top)</span>:</span></span><br><span class="line">        <span class="comment"># load image + label image pair</span></span><br><span class="line">        self.data = self.load_image(self.indices[self.idx])</span><br><span class="line">        self.label = self.load_label(self.indices[self.idx])</span><br><span class="line">        <span class="comment"># reshape tops to fit (leading 1 is for batch dimension)</span></span><br><span class="line">        top[<span class="number">0</span>].reshape(<span class="number">1</span>, *self.data.shape)</span><br><span class="line">        top[<span class="number">1</span>].reshape(<span class="number">1</span>, *self.label.shape)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, bottom, top)</span>:</span></span><br><span class="line">        <span class="comment"># assign output</span></span><br><span class="line">        top[<span class="number">0</span>].data[...] = self.data</span><br><span class="line">        top[<span class="number">1</span>].data[...] = self.label</span><br><span class="line"></span><br><span class="line">        <span class="comment"># pick next input</span></span><br><span class="line">        <span class="keyword">if</span> self.random:</span><br><span class="line">            self.idx = random.randint(<span class="number">0</span>, len(self.indices)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.idx == len(self.indices):</span><br><span class="line">                self.idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(self, top, propagate_down, bottom)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_image</span><span class="params">(self, idx)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Load input image and preprocess for Caffe:</span></span><br><span class="line"><span class="string">        - cast to float</span></span><br><span class="line"><span class="string">        - switch channels RGB -&gt; BGR</span></span><br><span class="line"><span class="string">        - subtract mean</span></span><br><span class="line"><span class="string">        - transpose to channel x height x width order</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        im = Image.open(<span class="string">'&#123;&#125;/JPEGImages/&#123;&#125;.jpg'</span>.format(self.voc_dir, idx))</span><br><span class="line">        in_ = np.array(im, dtype=np.float32)</span><br><span class="line">        in_ = in_[:,:,::<span class="number">-1</span>]</span><br><span class="line">        in_ -= self.mean</span><br><span class="line">        in_ = in_.transpose((<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> in_</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_label</span><span class="params">(self, idx)</span>:</span></span><br><span class="line"></span><br><span class="line">        label_111 = scipy.io.loadmat(<span class="string">'&#123;&#125;/trainval/&#123;&#125;.mat'</span>.format(self.context_dir, idx))[<span class="string">'LabelMap'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> label_111</span><br></pre></td></tr></table></figure>
<h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a><strong>训练模型</strong></h3><ol>
<li><p>运行<code>net.py</code>生成<code>train.prototxt</code>和<code>val.prototxt</code></p>
</li>
<li><p>可以更改<code>solver.prototxt</code>更改训练策略, 运行<code>solve.py</code>训练模型</p>
</li>
</ol>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a><strong>相关资料</strong></h2><ol>
<li><p><a href="https://handong1587.github.io/deep_learning/2015/10/09/ocr.html" target="_blank" rel="noopener">OCR论文集</a></p>
</li>
<li><p><a href="http://www.robots.ox.ac.uk/~vgg/publications/2016/Gupta16/" target="_blank" rel="noopener">Synthetic Data for Text Localisation in Natural Images</a></p>
</li>
</ol>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/12/20/PaddlePaddle/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          PaddlePaddle
        
      </div>
    </a>
  
  
    <a href="/2016/11/16/文本分类实践/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">文本分类实践</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>










</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 simshang
			<a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia Theme</a>
		</div>
      	<div class="footer-right">
			<a href="https://www.google.com/chrome/browser/desktop/index.html" target="_blank">Chrome Recommended </a>
		</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<div id="totop" style="position:fixed;bottom:85px;right:-5px;cursor: pointer;">
    <a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>
<script src="/js/totop.js"></script>

  </div>
</body>
</html>
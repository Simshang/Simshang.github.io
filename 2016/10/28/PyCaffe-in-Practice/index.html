<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>PyCaffe in Practice | 简说</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在 Caffe in Action中我们已经介绍了如何编译pycaffe, 使用python来调用caffe的接口实现模型的定义和训练是十分方便的, 在权值和网络可视化方面也十分友好, 下面来学习一下pycaffe的使用">
<meta name="keywords" content="PyCaffe">
<meta property="og:type" content="article">
<meta property="og:title" content="PyCaffe in Practice">
<meta property="og:url" content="http://simtalk.cn/2016/10/28/PyCaffe-in-Practice/index.html">
<meta property="og:site_name" content="简说">
<meta property="og:description" content="在 Caffe in Action中我们已经介绍了如何编译pycaffe, 使用python来调用caffe的接口实现模型的定义和训练是十分方便的, 在权值和网络可视化方面也十分友好, 下面来学习一下pycaffe的使用">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://simtalk.cn/img/PyCaffe-in-Practice/caffenet.png">
<meta property="og:image" content="http://simtalk.cn/img/PyCaffe-in-Practice/loss.jpg">
<meta property="og:image" content="http://simtalk.cn/img/PyCaffe-in-Practice/visuconv1.png">
<meta property="og:image" content="http://simtalk.cn/img/PyCaffe-in-Practice/visuconv2.png">
<meta property="og:image" content="http://simtalk.cn/img/PyCaffe-in-Practice/visuconv3.png">
<meta property="og:image" content="http://simtalk.cn/img/PyCaffe-in-Practice/dog.png">
<meta property="og:image" content="http://simtalk.cn/img/PyCaffe-in-Practice/mean.png">
<meta property="og:image" content="http://simtalk.cn/img/PyCaffe-in-Practice/result1.png">
<meta property="og:image" content="http://simtalk.cn/img/PyCaffe-in-Practice/result2.png">
<meta property="og:image" content="http://simtalk.cn/img/PyCaffe-in-Practice/result3.png">
<meta property="og:image" content="http://simtalk.cn/img/PyCaffe-in-Practice/result.png">
<meta property="og:updated_time" content="2018-06-02T05:28:22.953Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PyCaffe in Practice">
<meta name="twitter:description" content="在 Caffe in Action中我们已经介绍了如何编译pycaffe, 使用python来调用caffe的接口实现模型的定义和训练是十分方便的, 在权值和网络可视化方面也十分友好, 下面来学习一下pycaffe的使用">
<meta name="twitter:image" content="http://simtalk.cn/img/PyCaffe-in-Practice/caffenet.png">
  
    <link rel="alternative" href="/atom.xml" title="简说" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xqkff.com1.z0.glb.clouddn.com/AIer.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">simshang</a></h1>
		</hgroup>

		
		<p class="header-subtitle">英泰勒吉斯就一定要实现</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/categories/life">生活</a></li>
				        
							<li><a href="/categories/Ukelele">音乐</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Simshang" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/shangyan" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=l_T-9vnwue72_dfx_O-69v77ufT4_g" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/proto/" style="font-size: 10px;">.proto</a> <a href="/tags/3dConv/" style="font-size: 10px;">3dConv</a> <a href="/tags/AlexNet/" style="font-size: 10px;">AlexNet</a> <a href="/tags/BN/" style="font-size: 10px;">BN</a> <a href="/tags/BRIEF/" style="font-size: 10px;">BRIEF</a> <a href="/tags/BigO/" style="font-size: 10px;">BigO</a> <a href="/tags/Blobs/" style="font-size: 10px;">Blobs</a> <a href="/tags/BoW/" style="font-size: 10px;">BoW</a> <a href="/tags/C/" style="font-size: 14px;">C++</a> <a href="/tags/CDC/" style="font-size: 10px;">CDC</a> <a href="/tags/CNN/" style="font-size: 10px;">CNN</a> <a href="/tags/Caffe/" style="font-size: 18px;">Caffe</a> <a href="/tags/Container/" style="font-size: 10px;">Container</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Dockerhub/" style="font-size: 10px;">Dockerhub</a> <a href="/tags/Dropout/" style="font-size: 10px;">Dropout</a> <a href="/tags/FCN/" style="font-size: 12px;">FCN</a> <a href="/tags/FTP/" style="font-size: 10px;">FTP</a> <a href="/tags/GBD/" style="font-size: 10px;">GBD</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/GoogLeNet/" style="font-size: 10px;">GoogLeNet</a> <a href="/tags/Harris/" style="font-size: 10px;">Harris</a> <a href="/tags/Hexo/" style="font-size: 14px;">Hexo</a> <a href="/tags/IDE/" style="font-size: 10px;">IDE</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/LSTM/" style="font-size: 10px;">LSTM</a> <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/Layers/" style="font-size: 12px;">Layers</a> <a href="/tags/Linux/" style="font-size: 12px;">Linux</a> <a href="/tags/Make/" style="font-size: 10px;">Make</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Mysql/" style="font-size: 16px;">Mysql</a> <a href="/tags/NIN/" style="font-size: 10px;">NIN</a> <a href="/tags/Nets/" style="font-size: 10px;">Nets</a> <a href="/tags/ORB/" style="font-size: 10px;">ORB</a> <a href="/tags/OS/" style="font-size: 12px;">OS</a> <a href="/tags/Paddle/" style="font-size: 12px;">Paddle</a> <a href="/tags/PyCaffe/" style="font-size: 10px;">PyCaffe</a> <a href="/tags/Python/" style="font-size: 12px;">Python</a> <a href="/tags/RNN/" style="font-size: 10px;">RNN</a> <a href="/tags/ResNet/" style="font-size: 10px;">ResNet</a> <a href="/tags/SIFT/" style="font-size: 10px;">SIFT</a> <a href="/tags/SURF/" style="font-size: 10px;">SURF</a> <a href="/tags/SVM/" style="font-size: 10px;">SVM</a> <a href="/tags/Shell/" style="font-size: 10px;">Shell</a> <a href="/tags/Softmax/" style="font-size: 10px;">Softmax</a> <a href="/tags/Staple/" style="font-size: 10px;">Staple</a> <a href="/tags/TensorFlow/" style="font-size: 10px;">TensorFlow</a> <a href="/tags/UML/" style="font-size: 10px;">UML</a> <a href="/tags/VGG/" style="font-size: 10px;">VGG</a> <a href="/tags/Vim/" style="font-size: 10px;">Vim</a> <a href="/tags/kNN/" style="font-size: 10px;">kNN</a> <a href="/tags/内存/" style="font-size: 10px;">内存</a> <a href="/tags/单元测试/" style="font-size: 10px;">单元测试</a> <a href="/tags/反向传播算法/" style="font-size: 10px;">反向传播算法</a> <a href="/tags/图像增强/" style="font-size: 10px;">图像增强</a> <a href="/tags/图说/" style="font-size: 20px;">图说</a> <a href="/tags/工厂模式/" style="font-size: 10px;">工厂模式</a> <a href="/tags/并发编程/" style="font-size: 10px;">并发编程</a> <a href="/tags/摇滚/" style="font-size: 14px;">摇滚</a> <a href="/tags/文本分类/" style="font-size: 10px;">文本分类</a> <a href="/tags/最小二乘法/" style="font-size: 10px;">最小二乘法</a> <a href="/tags/梯度下降法/" style="font-size: 14px;">梯度下降法</a> <a href="/tags/模型优化/" style="font-size: 12px;">模型优化</a> <a href="/tags/正则化/" style="font-size: 12px;">正则化</a> <a href="/tags/激活函数/" style="font-size: 10px;">激活函数</a> <a href="/tags/电影/" style="font-size: 10px;">电影</a> <a href="/tags/神经网络/" style="font-size: 12px;">神经网络</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/线性模型/" style="font-size: 12px;">线性模型</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/随笔/" style="font-size: 12px;">随笔</a> <a href="/tags/面向对象/" style="font-size: 10px;">面向对象</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">北邮在读，计算机视觉与深度学习，喜欢摇滚乐，爱打篮球，极简主义。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">simshang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xqkff.com1.z0.glb.clouddn.com/AIer.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">simshang</h1>
			</hgroup>
			
			<p class="header-subtitle">英泰勒吉斯就一定要实现</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/categories/life">生活</a></li>
		        
					<li><a href="/categories/Ukelele">音乐</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Simshang" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/shangyan" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=l_T-9vnwue72_dfx_O-69v77ufT4_g" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-PyCaffe-in-Practice" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/10/28/PyCaffe-in-Practice/" class="article-date">
  	<time datetime="2016-10-28T06:53:12.000Z" itemprop="datePublished">2016-10-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      PyCaffe in Practice
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PyCaffe/">PyCaffe</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Caffe/">Caffe</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <div id="toc" class="toc-article">
            <strong class="toc-title">文章目录</strong>
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#生成网络"><span class="toc-text">生成网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生成solver"><span class="toc-text">生成solver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模型训练"><span class="toc-text">模型训练</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mnist实例"><span class="toc-text">Mnist实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生成deploy"><span class="toc-text">生成deploy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#预测分类"><span class="toc-text">预测分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络可视化"><span class="toc-text">网络可视化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loss可视化"><span class="toc-text">loss可视化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特征可视化"><span class="toc-text">特征可视化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模型可视化"><span class="toc-text">模型可视化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据可视化"><span class="toc-text">数据可视化</span></a></li></ol>
        </div>
        
        <p>在 <a href="http://simtalk.cn/2016/09/14/Caffe-in-Action/#pycaffe">Caffe in Action</a>中我们已经介绍了如何编译pycaffe, 使用python来调用caffe的接口实现模型的定义和训练是十分方便的, 在权值和网络可视化方面也十分友好, 下面来学习一下pycaffe的使用</p>
<a id="more"></a>
<blockquote>
<p>运行环境是我的caffe docker镜像, 见<a href="https://dev.aliyun.com/detail.html?spm=5176.1972343.2.22.7Ole2f&amp;repoId=17725" target="_blank" rel="noopener">shang/caffe</a></p>
</blockquote>
<h3 id="生成网络"><a href="#生成网络" class="headerlink" title="生成网络"></a><strong>生成网络</strong></h3><p>在开始之前要确保pycaffe编译成功, 并且将图片数据转化为LMDB文件<code>.mdb</code>, 拥有图像的均值文件<code>mean.binaryproto</code> 我们拿<code>cifar10</code>作为数据集进行实验</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> caffe <span class="keyword">import</span> layers <span class="keyword">as</span> L, params <span class="keyword">as</span> P, to_proto</span><br><span class="line"></span><br><span class="line">path = <span class="string">'/root/caffe/examples/cifar10/'</span>  <span class="comment"># 保存数据和配置文件的路径</span></span><br><span class="line">train_lmdb = path + <span class="string">'cifar10_train_lmdb'</span>  <span class="comment"># 训练数据LMDB文件的位置</span></span><br><span class="line">val_lmdb = path + <span class="string">'cifar10_test_lmdb'</span>  <span class="comment"># 验证数据LMDB文件的位置</span></span><br><span class="line">mean_file = path + <span class="string">'mean.binaryproto'</span>  <span class="comment"># 均值文件的位置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_proto = path + <span class="string">'train_shang.prototxt'</span>  <span class="comment"># 生成的训练配置文件保存的位置</span></span><br><span class="line">val_proto = path + <span class="string">'val_shang.prototxt'</span>  <span class="comment"># 生成的验证配置文件保存的位置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写一个函数，用于生成网络</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_net</span><span class="params">(lmdb, batch_size, include_acc=False)</span>:</span></span><br><span class="line">    <span class="comment"># 创建第一层：数据层。向上传递两类数据：图片数据和对应的标签</span></span><br><span class="line">    data, label = L.Data(source=lmdb, backend=P.Data.LMDB, batch_size=batch_size, ntop=<span class="number">2</span>,</span><br><span class="line">                         transform_param=dict(crop_size=<span class="number">40</span>, mean_file=mean_file, mirror=<span class="keyword">True</span>))</span><br><span class="line">    <span class="comment"># 创建第二屋：卷积层</span></span><br><span class="line">    conv1 = L.Convolution(data, kernel_size=<span class="number">5</span>, stride=<span class="number">1</span>, num_output=<span class="number">16</span>, pad=<span class="number">2</span>, weight_filler=dict(type=<span class="string">'xavier'</span>))</span><br><span class="line">    <span class="comment"># 创建激活函数层</span></span><br><span class="line">    relu1 = L.ReLU(conv1, in_place=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment"># 创建池化层</span></span><br><span class="line">    pool1 = L.Pooling(relu1, pool=P.Pooling.MAX, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>)</span><br><span class="line">    conv2 = L.Convolution(pool1, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, num_output=<span class="number">32</span>, pad=<span class="number">1</span>, weight_filler=dict(type=<span class="string">'xavier'</span>))</span><br><span class="line">    relu2 = L.ReLU(conv2, in_place=<span class="keyword">True</span>)</span><br><span class="line">    pool2 = L.Pooling(relu2, pool=P.Pooling.MAX, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 创建一个全连接层</span></span><br><span class="line">    fc3 = L.InnerProduct(pool2, num_output=<span class="number">1024</span>, weight_filler=dict(type=<span class="string">'xavier'</span>))</span><br><span class="line">    relu3 = L.ReLU(fc3, in_place=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment"># 创建一个dropout层</span></span><br><span class="line">    drop3 = L.Dropout(relu3, in_place=<span class="keyword">True</span>)</span><br><span class="line">    fc4 = L.InnerProduct(drop3, num_output=<span class="number">10</span>, weight_filler=dict(type=<span class="string">'xavier'</span>))</span><br><span class="line">    <span class="comment"># 创建一个softmax层</span></span><br><span class="line">    loss = L.SoftmaxWithLoss(fc4, label)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> include_acc:  <span class="comment"># 在训练阶段，不需要accuracy层，但是在验证阶段，是需要的</span></span><br><span class="line">        acc = L.Accuracy(fc4, label)</span><br><span class="line">        <span class="keyword">return</span> to_proto(loss, acc)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> to_proto(loss)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_net</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 将以上的设置写入到prototxt文件</span></span><br><span class="line">    <span class="keyword">with</span> open(train_proto, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(str(create_net(train_lmdb, batch_size=<span class="number">64</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写入配置文件</span></span><br><span class="line">    <span class="keyword">with</span> open(val_proto, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(str(create_net(val_lmdb, batch_size=<span class="number">32</span>, include_acc=<span class="keyword">True</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    write_net()</span><br></pre></td></tr></table></figure>
<ul>
<li>在<code>/root/caffe/examples/cifar10/</code>下面可以看到生成了配置文件<code>train_shang.prototxt</code>和<code>val_shang.prototxt</code></li>
</ul>
<p>通过使用python这样就不用自己手动定义prototxt文件了否则将是一个很麻烦的事情</p>
<p>如果我们将原始图片不转化为lmdb文件, 那么可用ImageData作为数据源输入, 但是我们必须有<code>原始图片的列表清单</code>, 就是一个txt文件，内容是一行一张图片</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> caffe <span class="keyword">import</span> layers <span class="keyword">as</span> L,params <span class="keyword">as</span> P,to_proto</span><br><span class="line">path=<span class="string">'/home/xxx/data/'</span></span><br><span class="line">train_list=path+<span class="string">'train.txt'</span></span><br><span class="line">val_list=path+<span class="string">'val.txt'</span> </span><br><span class="line">          </span><br><span class="line">train_proto=path+<span class="string">'train.prototxt'</span>   </span><br><span class="line">val_proto=path+<span class="string">'val.prototxt'</span>       </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_net</span><span class="params">(img_list,batch_size,include_acc=False)</span>:</span></span><br><span class="line">    data,label=L.ImageData(source=img_list,batch_size=batch_size,new_width=<span class="number">48</span>,new_height=<span class="number">48</span>,ntop=<span class="number">2</span>,</span><br><span class="line">                           transform_param=dict(crop_size=<span class="number">40</span>,mirror=<span class="keyword">True</span>))</span><br><span class="line"></span><br><span class="line">    conv1=L.Convolution(data, kernel_size=<span class="number">5</span>, stride=<span class="number">1</span>,num_output=<span class="number">16</span>, pad=<span class="number">2</span>,weight_filler=dict(type=<span class="string">'xavier'</span>))</span><br><span class="line">    relu1=L.ReLU(conv1, in_place=<span class="keyword">True</span>)</span><br><span class="line">    pool1=L.Pooling(relu1, pool=P.Pooling.MAX, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>)</span><br><span class="line">    conv2=L.Convolution(pool1, kernel_size=<span class="number">53</span>, stride=<span class="number">1</span>,num_output=<span class="number">32</span>, pad=<span class="number">1</span>,weight_filler=dict(type=<span class="string">'xavier'</span>))</span><br><span class="line">    relu2=L.ReLU(conv2, in_place=<span class="keyword">True</span>)</span><br><span class="line">    pool2=L.Pooling(relu2, pool=P.Pooling.MAX, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>)</span><br><span class="line">    conv3=L.Convolution(pool2, kernel_size=<span class="number">53</span>, stride=<span class="number">1</span>,num_output=<span class="number">32</span>, pad=<span class="number">1</span>,weight_filler=dict(type=<span class="string">'xavier'</span>))</span><br><span class="line">    relu3=L.ReLU(conv3, in_place=<span class="keyword">True</span>)</span><br><span class="line">    pool3=L.Pooling(relu3, pool=P.Pooling.MAX, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>)</span><br><span class="line">    fc4=L.InnerProduct(pool3, num_output=<span class="number">1024</span>,weight_filler=dict(type=<span class="string">'xavier'</span>))</span><br><span class="line">    relu4=L.ReLU(fc4, in_place=<span class="keyword">True</span>)</span><br><span class="line">    drop4 = L.Dropout(relu4, in_place=<span class="keyword">True</span>)</span><br><span class="line">    fc5 = L.InnerProduct(drop4, num_output=<span class="number">7</span>,weight_filler=dict(type=<span class="string">'xavier'</span>))</span><br><span class="line">    loss = L.SoftmaxWithLoss(fc5, label)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> include_acc:             </span><br><span class="line">        acc = L.Accuracy(fc5, label)</span><br><span class="line">        <span class="keyword">return</span> to_proto(loss, acc)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> to_proto(loss)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_net</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">with</span> open(train_proto, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(str(create_net(train_list,batch_size=<span class="number">64</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#    </span></span><br><span class="line">    <span class="keyword">with</span> open(val_proto, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(str(create_net(val_list,batch_size=<span class="number">32</span>, include_acc=<span class="keyword">True</span>)))</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    write_net()</span><br></pre></td></tr></table></figure>
<ul>
<li>即第一层由原来的Data类型，变成了ImageData类型，不需要LMDB文件和均值文件，只需要一个txt文件</li>
</ul>
<h3 id="生成solver"><a href="#生成solver" class="headerlink" title="生成solver"></a><strong>生成solver</strong></h3><p>Caffe在训练的时候，需要一些参数设置，我们一般将这些参数设置在一个叫solver.prototxt的文件里面</p>
<ul>
<li><p>如果有50000个训练样本，batch_size为64，即每批次处理64个样本，那么需要迭代50000/64=782次才处理完一次全部的样本。我们把处理完一次所有的样本，称之为一代，即epoch。所以，这里的test_interval设置为782，即处理完一次所有的训练数据后，才去进行测试。如果我们想训练100代，则需要设置max_iter为78200</p>
</li>
<li><p>如果有10000个测试样本，batch_size设为32，那么需要迭代10000/32=313次才完整地测试完一次，所以设置test_iter为313</p>
</li>
<li><p>学习率变化规律我们设置为随着迭代次数的增加，慢慢变低。总共迭代78200次，我们将变化lr_rate三次，所以stepsize设置为78200/3=26067，即每迭代26067次，我们就降低一次学习率</p>
</li>
</ul>
<p>那么我们的solver.prototxt如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">base_lr: <span class="number">0.001</span></span><br><span class="line">display: <span class="number">782</span></span><br><span class="line">gamma: <span class="number">0.1</span></span><br><span class="line">lr_policy: <span class="string">"step"</span></span><br><span class="line">max_iter: <span class="number">78200</span></span><br><span class="line">momentum: <span class="number">0.9</span></span><br><span class="line">snapshot: <span class="number">7820</span></span><br><span class="line">snapshot_prefix: <span class="string">"snapshot"</span></span><br><span class="line">solver_mode: GPU</span><br><span class="line">solver_type: SGD</span><br><span class="line">stepsize: <span class="number">26067</span></span><br><span class="line">test_interval: <span class="number">782</span></span><br><span class="line">test_iter: <span class="number">313</span></span><br><span class="line">test_net: <span class="string">"/root/caffe/examples/cifar10/val.prototxt"</span></span><br><span class="line">train_net: <span class="string">"/root/caffe/examples/cifar10/train.prototxt"</span></span><br><span class="line">weight_decay: <span class="number">0.0005</span></span><br></pre></td></tr></table></figure>
<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">path = <span class="string">'/root/caffe/examples/cifar10/'</span></span><br><span class="line">solver_file=path+<span class="string">'solver_shang.prototxt'</span>     <span class="comment">#solver文件保存位置</span></span><br><span class="line"></span><br><span class="line">sp=&#123;&#125;</span><br><span class="line">sp[<span class="string">'train_net'</span>]=<span class="string">'"'</span>+path+<span class="string">'train.prototxt"'</span>  <span class="comment"># 训练配置文件</span></span><br><span class="line">sp[<span class="string">'test_net'</span>]=<span class="string">'"'</span>+path+<span class="string">'val.prototxt"'</span>     <span class="comment"># 测试配置文件</span></span><br><span class="line">sp[<span class="string">'test_iter'</span>]=<span class="string">'313'</span>                  <span class="comment"># 测试迭代次数</span></span><br><span class="line">sp[<span class="string">'test_interval'</span>]=<span class="string">'782'</span>              <span class="comment"># 测试间隔</span></span><br><span class="line">sp[<span class="string">'base_lr'</span>]=<span class="string">'0.001'</span>                  <span class="comment"># 基础学习率</span></span><br><span class="line">sp[<span class="string">'display'</span>]=<span class="string">'782'</span>                    <span class="comment"># 屏幕日志显示间隔</span></span><br><span class="line">sp[<span class="string">'max_iter'</span>]=<span class="string">'78200'</span>                 <span class="comment"># 最大迭代次数</span></span><br><span class="line">sp[<span class="string">'lr_policy'</span>]=<span class="string">'"step"'</span>                 <span class="comment"># 学习率变化规律</span></span><br><span class="line">sp[<span class="string">'gamma'</span>]=<span class="string">'0.1'</span>                      <span class="comment"># 学习率变化指数</span></span><br><span class="line">sp[<span class="string">'momentum'</span>]=<span class="string">'0.9'</span>                   <span class="comment"># 动量</span></span><br><span class="line">sp[<span class="string">'weight_decay'</span>]=<span class="string">'0.0005'</span>            <span class="comment"># 权值衰减</span></span><br><span class="line">sp[<span class="string">'stepsize'</span>]=<span class="string">'26067'</span>                 <span class="comment"># 学习率变化频率</span></span><br><span class="line">sp[<span class="string">'snapshot'</span>]=<span class="string">'7820'</span>                   <span class="comment"># 保存model间隔</span></span><br><span class="line">sp[<span class="string">'snapshot_prefix'</span>]=<span class="string">'"snapshot"'</span>    <span class="comment"># 保存的model前缀</span></span><br><span class="line">sp[<span class="string">'solver_mode'</span>]=<span class="string">'GPU'</span>                <span class="comment"># 是否使用gpu</span></span><br><span class="line">sp[<span class="string">'solver_type'</span>]=<span class="string">'SGD'</span>                <span class="comment"># 优化算法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_solver</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#写入文件</span></span><br><span class="line">    <span class="keyword">with</span> open(solver_file, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> sorted(sp.items()):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span>(type(value) <span class="keyword">is</span> str):</span><br><span class="line">                <span class="keyword">raise</span> TypeError(<span class="string">'All solver parameters must be strings'</span>)</span><br><span class="line">            f.write(<span class="string">'%s: %s\n'</span> % (key, value))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    write_solver()</span><br></pre></td></tr></table></figure>
<p>如果你觉得上面这种键值对的字典方式，写起来容易出错，我们也可以使用另外一种比较简便的方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> caffe.proto <span class="keyword">import</span> caffe_pb2</span><br><span class="line">s = caffe_pb2.SolverParameter()</span><br><span class="line"></span><br><span class="line">path=<span class="string">'/home/xxx/data/'</span></span><br><span class="line">solver_file=path+<span class="string">'solver1.prototxt'</span></span><br><span class="line"></span><br><span class="line">s.train_net = path+<span class="string">'train.prototxt'</span></span><br><span class="line">s.test_net.append(path+<span class="string">'val.prototxt'</span>)</span><br><span class="line">s.test_interval = <span class="number">782</span>  </span><br><span class="line">s.test_iter.append(<span class="number">313</span>) </span><br><span class="line">s.max_iter = <span class="number">78200</span> </span><br><span class="line"></span><br><span class="line">s.base_lr = <span class="number">0.001</span> </span><br><span class="line">s.momentum = <span class="number">0.9</span></span><br><span class="line">s.weight_decay = <span class="number">5e-4</span></span><br><span class="line">s.lr_policy = <span class="string">'step'</span></span><br><span class="line">s.stepsize=<span class="number">26067</span></span><br><span class="line">s.gamma = <span class="number">0.1</span></span><br><span class="line">s.display = <span class="number">782</span></span><br><span class="line">s.snapshot = <span class="number">7820</span></span><br><span class="line">s.snapshot_prefix = <span class="string">'shapshot'</span></span><br><span class="line">s.type = “SGD”</span><br><span class="line">s.solver_mode = caffe_pb2.SolverParameter.GPU</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(solver_file, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(str(s))</span><br></pre></td></tr></table></figure>
<p>得到一个solver.prototxt文件，有了这个文件，我们下一步就可以进行训练了</p>
<h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a><strong>模型训练</strong></h3><p><strong>特别注意,</strong> 该文件要放在caffe根目录下, 我的是<code>/root/caffe/</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> caffe</span><br><span class="line"><span class="comment"># python file under the /root/caffe/</span></span><br><span class="line">path = <span class="string">'/root/caffe/examples/cifar10/'</span></span><br><span class="line">caffe.set_mode_gpu()</span><br><span class="line">caffe.set_device(<span class="number">0</span>)</span><br><span class="line">solver = caffe.SGDSolver(path + <span class="string">'cifar10_quick_solver.prototxt'</span>)</span><br><span class="line">solver.solve()</span><br></pre></td></tr></table></figure>
<h3 id="Mnist实例"><a href="#Mnist实例" class="headerlink" title="Mnist实例"></a><strong>Mnist实例</strong></h3><ol>
<li><p>下载数据解压到<code>/root/caffe/example/</code>下, <a href="http://pan.baidu.com/s/1i4IUrDr" target="_blank" rel="noopener">百度云</a></p>
</li>
<li><p>clone代码, 放在<code>/root/caffe/example/mnist</code>下, <code>python mnist.py</code></p>
<p><a href="https://github.com/Simshang/pycaffe/blob/master/mnist.py" target="_blank" rel="noopener">mnist.py</a></p>
</li>
<li><p>结果:</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I1118 09:11:38.846159   671 solver.cpp:404]     Test net output #0: Accuracy1 = 0.9918</span><br><span class="line">I1118 09:11:38.846225   671 solver.cpp:404]     Test net output #1: SoftmaxWithLoss1 = 0.0278273 (* 1 = 0.0278273 loss)</span><br><span class="line">I1118 09:11:38.846235   671 solver.cpp:322] Optimization Done.</span><br></pre></td></tr></table></figure>
<h3 id="生成deploy"><a href="#生成deploy" class="headerlink" title="生成deploy"></a><strong>生成deploy</strong></h3><p>如果要把训练好的模型拿来测试新的图片，那必须得要一个deploy.prototxt文件，这个文件实际上和test.prototxt文件差不多，只是头尾不相同而也。deploy文件没有第一层数据输入层，也没有最后的Accuracy层，但最后多了一个Softmax概率层。</p>
<p>这里我们采用代码的方式来自动生成该文件，以mnist为例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> caffe <span class="keyword">import</span> layers <span class="keyword">as</span> L,params <span class="keyword">as</span> P,to_proto</span><br><span class="line">root = <span class="string">'/root/caffe/examples/'</span></span><br><span class="line">deploy=root+<span class="string">'mnist/deploy.prototxt'</span>    <span class="comment">#文件保存路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_deploy</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#少了第一层，data层</span></span><br><span class="line">    conv1=L.Convolution(bottom=<span class="string">'data'</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">1</span>,num_output=<span class="number">20</span>, pad=<span class="number">0</span>,weight_filler=dict(type=<span class="string">'xavier'</span>))</span><br><span class="line">    pool1=L.Pooling(conv1, pool=P.Pooling.MAX, kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)</span><br><span class="line">    conv2=L.Convolution(pool1, kernel_size=<span class="number">5</span>, stride=<span class="number">1</span>,num_output=<span class="number">50</span>, pad=<span class="number">0</span>,weight_filler=dict(type=<span class="string">'xavier'</span>))</span><br><span class="line">    pool2=L.Pooling(conv2, pool=P.Pooling.MAX, kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)</span><br><span class="line">    fc3=L.InnerProduct(pool2, num_output=<span class="number">500</span>,weight_filler=dict(type=<span class="string">'xavier'</span>))</span><br><span class="line">    relu3=L.ReLU(fc3, in_place=<span class="keyword">True</span>)</span><br><span class="line">    fc4 = L.InnerProduct(relu3, num_output=<span class="number">10</span>,weight_filler=dict(type=<span class="string">'xavier'</span>))</span><br><span class="line">    <span class="comment">#最后没有accuracy层，但有一个Softmax层</span></span><br><span class="line">    prob=L.Softmax(fc4)</span><br><span class="line">    <span class="keyword">return</span> to_proto(prob)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_deploy</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(deploy, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">'name:"Lenet"\n'</span>)</span><br><span class="line">        f.write(<span class="string">'input:"data"\n'</span>)</span><br><span class="line">        f.write(<span class="string">'input_dim:1\n'</span>)</span><br><span class="line">        f.write(<span class="string">'input_dim:3\n'</span>)</span><br><span class="line">        f.write(<span class="string">'input_dim:28\n'</span>)</span><br><span class="line">        f.write(<span class="string">'input_dim:28\n'</span>)</span><br><span class="line">        f.write(str(create_deploy()))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    write_deploy()</span><br></pre></td></tr></table></figure>
<h3 id="预测分类"><a href="#预测分类" class="headerlink" title="预测分类"></a><strong>预测分类</strong></h3><p>到此为止, 我们已经训练好了一个mnist的caffemodel的模型, 并且生成了deploy.prototxt文件, 现在我们就利用这两个文件来对一个新的图片进行分类预测。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> caffe</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">root = <span class="string">'/root/caffe/examples/'</span>  <span class="comment"># 根目录</span></span><br><span class="line">deploy=root + <span class="string">'mnist/deploy.prototxt'</span>    <span class="comment">#deploy文件</span></span><br><span class="line">caffe_model=root + <span class="string">'mnist/lenet_iter_9380.caffemodel'</span>   <span class="comment">#训练好的 caffemodel</span></span><br><span class="line">img=root+<span class="string">'mnist/test/5/00008.png'</span>    <span class="comment">#随机找的一张待测图片</span></span><br><span class="line">labels_filename = root + <span class="string">'mnist/test/labels.txt'</span>  <span class="comment">#类别名称文件，将数字标签转换回类别名称</span></span><br><span class="line"></span><br><span class="line">net = caffe.Net(deploy,caffe_model,caffe.TEST)   <span class="comment">#加载model和network</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#图片预处理设置</span></span><br><span class="line">transformer = caffe.io.Transformer(&#123;<span class="string">'data'</span>: net.blobs[<span class="string">'data'</span>].data.shape&#125;)  <span class="comment">#设定图片的shape格式(1,3,28,28)</span></span><br><span class="line">transformer.set_transpose(<span class="string">'data'</span>, (<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>))    <span class="comment">#改变维度的顺序，由原始图片(28,28,3)变为(3,28,28)</span></span><br><span class="line"><span class="comment">#transformer.set_mean('data', np.load(mean_file).mean(1).mean(1))    #减去均值，前面训练模型时没有减均值，这儿就不用</span></span><br><span class="line">transformer.set_raw_scale(<span class="string">'data'</span>, <span class="number">255</span>)    <span class="comment"># 缩放到[0，255]之间</span></span><br><span class="line">transformer.set_channel_swap(<span class="string">'data'</span>, (<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>))   <span class="comment">#交换通道，将图片由RGB变为BGR</span></span><br><span class="line">im=caffe.io.load_image(img)                   <span class="comment">#加载图片</span></span><br><span class="line">net.blobs[<span class="string">'data'</span>].data[...] = transformer.preprocess(<span class="string">'data'</span>,im)      <span class="comment">#执行上面设置的图片预处理操作，并将图片载入到blob中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行测试</span></span><br><span class="line">out = net.forward()</span><br><span class="line">labels = np.loadtxt(labels_filename, str, delimiter=<span class="string">'\t'</span>)   <span class="comment">#读取类别名称文件</span></span><br><span class="line">prob= net.blobs[<span class="string">'Softmax1'</span>].data[<span class="number">0</span>].flatten() <span class="comment">#取出最后一层（Softmax）属于某个类别的概率值，并打印</span></span><br><span class="line"><span class="keyword">print</span> prob</span><br><span class="line">order=prob.argsort()[<span class="number">-1</span>]  <span class="comment">#将概率值排序，取出最大值所在的序号</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'the class is:'</span>,labels[order]   <span class="comment">#将该序号转换成对应的类别名称，并打印</span></span><br></pre></td></tr></table></figure>
<ul>
<li>输出结果:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ 0.  0.  0.  0.  0.  1.  0.  0.  0.  0.]</span><br><span class="line">the class is: 5</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="网络可视化"><a href="#网络可视化" class="headerlink" title="网络可视化"></a><strong>网络可视化</strong></h3><p>$ <code>python draw_net.py ../models/bvlc_reference_caffenet/train_val.prototxt caffenet.png</code></p>
<p>Drawing net to caffenet.png</p>
<p>draw_net.py执行的时候带三个参数:</p>
<ul>
<li><p>第一个参数：网络模型的prototxt文件</p>
</li>
<li><p>第二个参数：保存的图片路径及名字</p>
</li>
<li><p>第三个参数：<code>--rankdir=x</code> , x 有四种选项，分别是LR, RL, TB, BT 。用来表示网络的方向，分别是从左到右，从右到左，从上到下，从下到上。默认为LR</p>
</li>
<li><p>如下图所示:</p>
</li>
</ul>
<p><img src="\img\PyCaffe-in-Practice\caffenet.png" alt=""></p>
<ul>
<li>需要的库</li>
</ul>
<p><code>pip install pydot==1.1.0</code></p>
<p><code>apt-get install graphviz</code></p>
<h3 id="loss可视化"><a href="#loss可视化" class="headerlink" title="loss可视化"></a><strong>loss可视化</strong></h3><p>将训练过程中的loss和acc画出来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">'Agg'</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib.pyplot <span class="keyword">import</span> savefig</span><br><span class="line"><span class="keyword">import</span> caffe</span><br><span class="line"></span><br><span class="line">caffe.set_device(<span class="number">0</span>)</span><br><span class="line">caffe.set_mode_gpu()</span><br><span class="line">path = <span class="string">'/root/caffe/examples/'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用SGDSolver，即随机梯度下降算法</span></span><br><span class="line">solver = caffe.SGDSolver(path + <span class="string">'mnist/solver.prototxt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于solver文件中的max_iter，即最大解算次数</span></span><br><span class="line">niter = <span class="number">9380</span></span><br><span class="line"><span class="comment"># 每隔100次收集一次数据</span></span><br><span class="line">display = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次测试进行100次解算，10000/100</span></span><br><span class="line">test_iter = <span class="number">100</span></span><br><span class="line"><span class="comment"># 每500次训练进行一次测试（100次解算），60000/64</span></span><br><span class="line">test_interval = <span class="number">938</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">train_loss = numpy.zeros(numpy.ceil(niter * <span class="number">1.0</span> / display))</span><br><span class="line">test_loss = numpy.zeros(numpy.ceil(niter * <span class="number">1.0</span> / test_interval))</span><br><span class="line">test_acc = numpy.zeros(numpy.ceil(niter * <span class="number">1.0</span> / test_interval))</span><br><span class="line"></span><br><span class="line"><span class="comment"># iteration 0，不计入</span></span><br><span class="line">solver.step(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 辅助变量</span></span><br><span class="line">_train_loss = <span class="number">0</span>;</span><br><span class="line">_test_loss = <span class="number">0</span>;</span><br><span class="line">_accuracy = <span class="number">0</span></span><br><span class="line"><span class="comment"># 进行解算</span></span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> range(niter):</span><br><span class="line">    <span class="comment"># 进行一次解算</span></span><br><span class="line">    solver.step(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 每迭代一次，训练batch_size张图片</span></span><br><span class="line">    _train_loss += solver.net.blobs[<span class="string">'SoftmaxWithLoss1'</span>].data</span><br><span class="line">    <span class="keyword">if</span> it % display == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 计算平均train loss</span></span><br><span class="line">        train_loss[it // display] = _train_loss / display</span><br><span class="line">        _train_loss = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> it % test_interval == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> test_it <span class="keyword">in</span> range(test_iter):</span><br><span class="line">            <span class="comment"># 进行一次测试</span></span><br><span class="line">            solver.test_nets[<span class="number">0</span>].forward()</span><br><span class="line">            <span class="comment"># 计算test loss</span></span><br><span class="line">            _test_loss += solver.test_nets[<span class="number">0</span>].blobs[<span class="string">'SoftmaxWithLoss1'</span>].data</span><br><span class="line">            <span class="comment"># 计算test accuracy</span></span><br><span class="line">            _accuracy += solver.test_nets[<span class="number">0</span>].blobs[<span class="string">'Accuracy1'</span>].data</span><br><span class="line">            <span class="comment"># 计算平均test loss</span></span><br><span class="line">        test_loss[it / test_interval] = _test_loss / test_iter</span><br><span class="line">        <span class="comment"># 计算平均test accuracy</span></span><br><span class="line">        test_acc[it / test_interval] = _accuracy / test_iter</span><br><span class="line">        _test_loss = <span class="number">0</span></span><br><span class="line">        _accuracy = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 绘制train loss、test loss和accuracy曲线</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'\nplot the train loss and test accuracy\n'</span></span><br><span class="line">_, ax1 = plt.subplots()</span><br><span class="line">ax2 = ax1.twinx()</span><br><span class="line"></span><br><span class="line"><span class="comment"># train loss -&gt; 绿色</span></span><br><span class="line">ax1.plot(display * numpy.arange(len(train_loss)), train_loss, <span class="string">'g'</span>)</span><br><span class="line"><span class="comment"># test loss -&gt; 黄色</span></span><br><span class="line">ax1.plot(test_interval * numpy.arange(len(test_loss)), test_loss, <span class="string">'y'</span>)</span><br><span class="line"><span class="comment"># test accuracy -&gt; 红色</span></span><br><span class="line">ax2.plot(test_interval * numpy.arange(len(test_acc)), test_acc, <span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line">ax1.set_xlabel(<span class="string">'iteration'</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">'loss'</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">'accuracy'</span>)</span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line">savefig(<span class="string">'./loss.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\nplot finish!!!\n"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>由于在Linux终端下我们将结果保存为<code>loss.jpg</code>, 保存路径为当前目录</li>
</ul>
<p><img src="/img/PyCaffe-in-Practice/loss.jpg" alt=""></p>
<h3 id="特征可视化"><a href="#特征可视化" class="headerlink" title="特征可视化"></a><strong>特征可视化</strong></h3><p>在整个训练过程中, 模型的参数保存在<code>caffemodel</code>文件里, 实际上就是各层的w和b值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> caffe</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">root = <span class="string">'/root/caffe/examples/'</span>   <span class="comment">#根目录</span></span><br><span class="line">deploy=root + <span class="string">'mnist/deploy.prototxt'</span>    <span class="comment">#deploy文件</span></span><br><span class="line">caffe_model=root + <span class="string">'mnist/lenet_iter_9380.caffemodel'</span>   <span class="comment">#训练好的 caffemodel</span></span><br><span class="line">net = caffe.Net(deploy,caffe_model,caffe.TEST)   <span class="comment">#加载model和network</span></span><br><span class="line"></span><br><span class="line">[(k,v[<span class="number">0</span>].data.shape) <span class="keyword">for</span> k,v <span class="keyword">in</span> net.params.items()]  <span class="comment">#查看各层参数规模</span></span><br><span class="line">w1=net.params[<span class="string">'Convolution1'</span>][<span class="number">0</span>].data  <span class="comment">#提取参数w</span></span><br><span class="line">b1=net.params[<span class="string">'Convolution1'</span>][<span class="number">1</span>].data  <span class="comment">#提取参数b</span></span><br><span class="line"></span><br><span class="line">net.forward()   <span class="comment">#运行测试</span></span><br><span class="line">[(k,v.data.shape) <span class="keyword">for</span> k,v <span class="keyword">in</span> net.blobs.items()]  <span class="comment">#查看各层数据规模</span></span><br><span class="line">fea=net.blobs[<span class="string">'InnerProduct1'</span>].data   <span class="comment">#提取某层数据（特征）</span></span><br><span class="line"><span class="keyword">print</span> fea</span><br></pre></td></tr></table></figure>
<ul>
<li><p>所有的参数和数据都加载到一个net变量里, 这是一个很复杂的对象, 其中<code>net.params: 保存各层的参数值（w和b)</code>, <code>net.blobs: 保存各层的数据值</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(k,v[<span class="number">0</span>].data) <span class="keyword">for</span> k,v <span class="keyword">in</span> net.params.items()]</span><br><span class="line"><span class="comment"># 只看参数的shape</span></span><br><span class="line">[(k,v[<span class="number">0</span>].data.shape) <span class="keyword">for</span> k,v <span class="keyword">in</span> net.params.items()]</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看各层的参数值，其中k表示层的名称，v[0].data就是各层的W值，而v[1].data是各层的b值。</p>
</li>
<li>注意：并不是所有的层都有参数，只有卷积层和全连接层才有</li>
</ul>
<p>假设我们知道其中第一个卷积层的名字叫’Convolution1’, 则我们可以提取这个层的参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w1=net.params[<span class="string">'Convolution1'</span>][<span class="number">0</span>].data</span><br><span class="line">b1=net.params[<span class="string">'Convolution1'</span>][<span class="number">1</span>].data</span><br></pre></td></tr></table></figure></p>
<p>除了查看参数，我们还可以查看数据，但是要注意的是，net里面刚开始是没有数据的，需要运行<code>net.forward()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">net.forward()</span><br><span class="line"><span class="comment"># 运行之后才会有数据</span></span><br><span class="line">[(k,v.data) <span class="keyword">for</span> k,v <span class="keyword">in</span> net.blobs.items()]</span><br><span class="line"><span class="comment"># 只查看数据的shape</span></span><br><span class="line">[(k,v.data.shape) <span class="keyword">for</span> k,v <span class="keyword">in</span> net.blobs.items()]</span><br></pre></td></tr></table></figure>
<p>实际上数据刚输入的时候叫图片数据，卷积之后就叫特征, 只要知道某个层的名称，就可以抽取这个层的特征, 如果要抽取第一个全连接层的特征，则可用命令：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fea=net.blobs[<span class="string">'InnerProduct1'</span>].data</span><br><span class="line"><span class="keyword">print</span> fea</span><br></pre></td></tr></table></figure></p>
<h3 id="模型可视化"><a href="#模型可视化" class="headerlink" title="模型可视化"></a><strong>模型可视化</strong></h3><p>在训练过程中可以把训练好的模型保存起来，如lenet_iter_10000.caffemodel, 训练多少次就自动保存一下，这个是通过snapshot进行设置的，保存文件的路径及文件名前缀是由snapshot_prefix来设定的。这个文件里面存放的就是各层的参数，即net.params，里面没有数据(net.blobs)。还生成了一个相应的solverstate文件，这个和caffemodel差不多，但它多了一些数据，如模型名称、当前迭代次数等。两者的功能不一样，训练完后保存起来的caffemodel，是在测试阶段用来分类的，而solverstate是用来恢复训练的，防止意外终止而保存的快照, 相当于一个实时备份</p>
<ul>
<li>我们使用<code>Cifar10</code>作为例子:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os,sys,caffe</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">'Agg'</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.pyplot <span class="keyword">import</span> savefig</span><br><span class="line"></span><br><span class="line"><span class="comment">### 将相应的prototxt和caffemodel文件从服务器复制出来放在目录下</span></span><br><span class="line">caffe_root=<span class="string">'./'</span></span><br><span class="line">os.chdir(caffe_root)</span><br><span class="line">sys.path.insert(<span class="number">0</span>,caffe_root+<span class="string">'python'</span>)</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">8</span>, <span class="number">8</span>)</span><br><span class="line">plt.rcParams[<span class="string">'image.interpolation'</span>] = <span class="string">'nearest'</span></span><br><span class="line">plt.rcParams[<span class="string">'image.cmap'</span>] = <span class="string">'gray'</span></span><br><span class="line"></span><br><span class="line">net = caffe.Net(caffe_root + <span class="string">'cifar10_quick.prototxt'</span>,</span><br><span class="line">                caffe_root + <span class="string">'cifar10_quick_iter_5000.caffemodel'</span>,</span><br><span class="line">                caffe.TEST)</span><br><span class="line">[(k, v[<span class="number">0</span>].data.shape) <span class="keyword">for</span> k, v <span class="keyword">in</span> net.params.items()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写一个函数，用于显示各层的参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_feature</span><span class="params">(data, padsize=<span class="number">1</span>, padval=<span class="number">0</span>)</span>:</span></span><br><span class="line">    data -= data.min()</span><br><span class="line">    data /= data.max()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># force the number of filters to be square</span></span><br><span class="line">    n = int(np.ceil(np.sqrt(data.shape[<span class="number">0</span>])))</span><br><span class="line">    padding = ((<span class="number">0</span>, n ** <span class="number">2</span> - data.shape[<span class="number">0</span>]), (<span class="number">0</span>, padsize), (<span class="number">0</span>, padsize)) + ((<span class="number">0</span>, <span class="number">0</span>),) * (data.ndim - <span class="number">3</span>)</span><br><span class="line">    data = np.pad(data, padding, mode=<span class="string">'constant'</span>, constant_values=(padval, padval))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># tile the filters into an image</span></span><br><span class="line">    data = data.reshape((n, n) + data.shape[<span class="number">1</span>:]).transpose((<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>) + tuple(range(<span class="number">4</span>, data.ndim + <span class="number">1</span>)))</span><br><span class="line">    data = data.reshape((n * data.shape[<span class="number">1</span>], n * data.shape[<span class="number">3</span>]) + data.shape[<span class="number">4</span>:])</span><br><span class="line">    plt.imshow(data) <span class="comment"># 设断点</span></span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个卷积层，参数规模为(32,3,5,5)，即32个5*5的3通道filter</span></span><br><span class="line">weight = net.params[<span class="string">"conv1"</span>][<span class="number">0</span>].data</span><br><span class="line"><span class="comment"># 参数有两种类型：权值参数和偏置项,分别用params["conv1"][0] 和params["conv1"][1] 表示</span></span><br><span class="line"><span class="keyword">print</span> weight.shape</span><br><span class="line">show_feature(weight.transpose(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个卷积层的权值参数，共有32*32个filter,每个filter大小为5*5</span></span><br><span class="line">weight = net.params[<span class="string">"conv2"</span>][<span class="number">0</span>].data</span><br><span class="line"><span class="keyword">print</span> weight.shape</span><br><span class="line">show_feature(weight.reshape(<span class="number">32</span>*<span class="number">32</span>, <span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三个卷积层的权值，共有64*32个filter,每个filter大小为5*5，取其前1024个进行可视化</span></span><br><span class="line">weight = net.params[<span class="string">"conv3"</span>][<span class="number">0</span>].data</span><br><span class="line"><span class="keyword">print</span> weight.shape</span><br><span class="line">show_feature(weight.reshape(<span class="number">64</span>*<span class="number">32</span>,<span class="number">5</span>,<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p><strong>实验结果:</strong></p>
<p>第一个卷积层:</p>
<p><img src="/img/PyCaffe-in-Practice/visuconv1.png" alt=""><br>第二个卷积层:</p>
<p><img src="/img/PyCaffe-in-Practice/visuconv2.png" alt=""><br>第三个卷积层:</p>
<p><img src="/img/PyCaffe-in-Practice/visuconv3.png" alt=""></p>
<h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a><strong>数据可视化</strong></h3><p>在测试过程当中, 进行数据的可视化, 前提是得到caffemodel, 和一张测试图片, 我们在cifar10的dog类中选一张图片进行测试, 首先加载模型和测试图片代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> sys,os,caffe</span><br><span class="line">caffe_root = <span class="string">'./'</span></span><br><span class="line">sys.path.insert(<span class="number">0</span>, caffe_root + <span class="string">'python'</span>)</span><br><span class="line">os.chdir(caffe_root)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(caffe_root + <span class="string">'cifar10_quick_iter_4000.caffemodel'</span>):</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"caffemodel is not exist..."</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Ready to Go ..."</span></span><br><span class="line"></span><br><span class="line">caffe.set_mode_gpu()</span><br><span class="line"></span><br><span class="line">net = caffe.Net(caffe_root + <span class="string">'cifar10_quick.prototxt'</span>,</span><br><span class="line">                caffe_root + <span class="string">'cifar10_quick_iter_4000.caffemodel'</span>,</span><br><span class="line">                caffe.TEST)</span><br><span class="line"><span class="keyword">print</span> str(net.blobs[<span class="string">'data'</span>].data.shape)</span><br><span class="line"><span class="comment">#加载测试图片，并显示</span></span><br><span class="line">img = caffe.io.load_image(<span class="string">'./dog4.png'</span>)</span><br><span class="line"><span class="keyword">print</span> img.shape</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line"><span class="keyword">print</span> img.shape</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果:</li>
</ul>
<p><img src="/img/PyCaffe-in-Practice/dog.png" alt=""></p>
<p>然后编写一个函数，将二进制的均值转换为python的均值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_mean</span><span class="params">(binMean,npyMean)</span>:</span></span><br><span class="line">    blob = caffe.proto.caffe_pb2.BlobProto()</span><br><span class="line">    bin_mean = open(binMean, <span class="string">'rb'</span> ).read()</span><br><span class="line">    blob.ParseFromString(bin_mean)</span><br><span class="line">    arr = np.array( caffe.io.blobproto_to_array(blob) )</span><br><span class="line">    npy_mean = arr[<span class="number">0</span>]</span><br><span class="line">    np.save(npyMean, npy_mean )</span><br><span class="line">binMean=caffe_root+<span class="string">'examples/cifar10/mean.binaryproto'</span></span><br><span class="line">npyMean=caffe_root+<span class="string">'examples/cifar10/mean.npy'</span></span><br><span class="line">convert_mean(binMean,npyMean)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将图片载入blob中,并减去均值</span></span><br><span class="line">transformer = caffe.io.Transformer(&#123;<span class="string">'data'</span>: net.blobs[<span class="string">'data'</span>].data.shape&#125;)</span><br><span class="line">transformer.set_transpose(<span class="string">'data'</span>, (<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">transformer.set_mean(<span class="string">'data'</span>, np.load(npyMean).mean(<span class="number">1</span>).mean(<span class="number">1</span>)) <span class="comment"># 减去均值</span></span><br><span class="line">transformer.set_raw_scale(<span class="string">'data'</span>, <span class="number">255</span>)</span><br><span class="line">transformer.set_channel_swap(<span class="string">'data'</span>, (<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">net.blobs[<span class="string">'data'</span>].data[...] = transformer.preprocess(<span class="string">'data'</span>,img)</span><br><span class="line">inputData=net.blobs[<span class="string">'data'</span>].data</span><br><span class="line"><span class="comment">#显示减去均值前后的数据</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),plt.title(<span class="string">"origin"</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),plt.title(<span class="string">"subtract mean"</span>)</span><br><span class="line">plt.imshow(transformer.deprocess(<span class="string">'data'</span>, inputData[<span class="number">0</span>]))</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'subtract mean finished.'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>mean.binaryproto是由caffe本身自带的工具计算得来的, 上面的代码生成了<code>mean.npy</code>文件, 将测试图片进行预处理, 减去均值:</li>
</ul>
<p><img src="/img/PyCaffe-in-Practice/mean.png" alt=""></p>
<p>显示网络中每层的数据信息和参数信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行测试模型</span></span><br><span class="line">net.forward()</span><br><span class="line"><span class="comment">#显示各层数据信息</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Show data parameter:'</span></span><br><span class="line">data_shapes = [(k, v.data.shape) <span class="keyword">for</span> k, v <span class="keyword">in</span> net.blobs.items()]</span><br><span class="line"><span class="keyword">for</span> data_shape <span class="keyword">in</span> data_shapes:</span><br><span class="line">    <span class="keyword">print</span> data_shape</span><br><span class="line"><span class="comment"># 显示各层数据信息</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Show net parameter:'</span></span><br><span class="line">nets_shape = [(k, v[<span class="number">0</span>].data.shape) <span class="keyword">for</span> k, v <span class="keyword">in</span> net.params.items()]</span><br><span class="line"><span class="keyword">for</span> net_shape <span class="keyword">in</span> nets_shape:</span><br><span class="line">    <span class="keyword">print</span> net_shape</span><br></pre></td></tr></table></figure>
<p>下面编写一个函数，用于显示各层数据和参数, 并显示最后的分类概率:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编写一个函数，用于显示各层数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_data</span><span class="params">(data, padsize=<span class="number">1</span>, padval=<span class="number">0</span>)</span>:</span></span><br><span class="line">    data -= data.min()</span><br><span class="line">    data /= data.max()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># force the number of filters to be square</span></span><br><span class="line">    n = int(np.ceil(np.sqrt(data.shape[<span class="number">0</span>])))</span><br><span class="line">    padding = ((<span class="number">0</span>, n ** <span class="number">2</span> - data.shape[<span class="number">0</span>]), (<span class="number">0</span>, padsize), (<span class="number">0</span>, padsize)) + ((<span class="number">0</span>, <span class="number">0</span>),) * (data.ndim - <span class="number">3</span>)</span><br><span class="line">    data = np.pad(data, padding, mode=<span class="string">'constant'</span>, constant_values=(padval, padval))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># tile the filters into an image</span></span><br><span class="line">    data = data.reshape((n, n) + data.shape[<span class="number">1</span>:]).transpose((<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>) + tuple(range(<span class="number">4</span>, data.ndim + <span class="number">1</span>)))</span><br><span class="line">    data = data.reshape((n * data.shape[<span class="number">1</span>], n * data.shape[<span class="number">3</span>]) + data.shape[<span class="number">4</span>:])</span><br><span class="line">    plt.figure()   <span class="comment"># 设断点, 保存图片</span></span><br><span class="line">    plt.imshow(data, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'-----Show finished.------'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">8</span>, <span class="number">8</span>)</span><br><span class="line">plt.rcParams[<span class="string">'image.interpolation'</span>] = <span class="string">'nearest'</span></span><br><span class="line">plt.rcParams[<span class="string">'image.cmap'</span>] = <span class="string">'gray'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#显示第一个卷积层的输出数据和权值（filter）</span></span><br><span class="line">show_data(net.blobs[<span class="string">'conv1'</span>].data[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">print</span> net.blobs[<span class="string">'conv1'</span>].data.shape</span><br><span class="line">show_data(net.params[<span class="string">'conv1'</span>][<span class="number">0</span>].data.reshape(<span class="number">32</span>*<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"><span class="keyword">print</span> net.params[<span class="string">'conv1'</span>][<span class="number">0</span>].data.shape</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示第一次pooling后的输出数据</span></span><br><span class="line">show_data(net.blobs[<span class="string">'pool1'</span>].data[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">print</span> net.blobs[<span class="string">'pool1'</span>].data.shape</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示第二次卷积后的输出数据以及相应的权值（filter）</span></span><br><span class="line">show_data(net.blobs[<span class="string">'conv2'</span>].data[<span class="number">0</span>],padval=<span class="number">0.5</span>)</span><br><span class="line"><span class="keyword">print</span> net.blobs[<span class="string">'conv2'</span>].data.shape</span><br><span class="line">show_data(net.params[<span class="string">'conv2'</span>][<span class="number">0</span>].data.reshape(<span class="number">32</span>**<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"><span class="keyword">print</span> net.params[<span class="string">'conv2'</span>][<span class="number">0</span>].data.shape</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示第三次卷积后的输出数据以及相应的权值（filter）,取前１024个进行显示</span></span><br><span class="line">show_data(net.blobs[<span class="string">'conv3'</span>].data[<span class="number">0</span>],padval=<span class="number">0.5</span>)</span><br><span class="line"><span class="keyword">print</span> net.blobs[<span class="string">'conv3'</span>].data.shape</span><br><span class="line">show_data(net.params[<span class="string">'conv3'</span>][<span class="number">0</span>].data.reshape(<span class="number">64</span>*<span class="number">32</span>,<span class="number">5</span>,<span class="number">5</span>)[:<span class="number">1024</span>])</span><br><span class="line"><span class="keyword">print</span> net.params[<span class="string">'conv3'</span>][<span class="number">0</span>].data.shape</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示第三次池化后的输出数据</span></span><br><span class="line">show_data(net.blobs[<span class="string">'pool3'</span>].data[<span class="number">0</span>],padval=<span class="number">0.2</span>)</span><br><span class="line"><span class="keyword">print</span> net.blobs[<span class="string">'pool3'</span>].data.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后一层输入属于某个类的概率</span></span><br><span class="line">feat = net.blobs[<span class="string">'prob'</span>].data[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> feat <span class="comment"># 设断点</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(feat.flat)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Test finish.'</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/PyCaffe-in-Practice/result1.png" alt=""><br><img src="/img/PyCaffe-in-Practice/result2.png" alt=""><br><img src="/img/PyCaffe-in-Practice/result3.png" alt=""></p>
<p><strong>最终的分类结果:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[  2.96744809e-04   1.60467534e-05   3.39228063e-05   3.95220798e-03</span><br><span class="line">   8.45546026e-07   9.95582640e-01   1.68944953e-05   6.99048323e-05</span><br><span class="line">   4.91492074e-07   3.02444241e-05   ]</span><br></pre></td></tr></table></figure>
<p><img src="/img/PyCaffe-in-Practice/result.png" alt=""></p>
<p>从输入的结果和图示来看，最大的概率是9.95582640e-01，属于第５类（标号从０开始）。<br>与cifar10中的10种类型名称进行对比：</p>
<p>airplane[0]、automobile[1]、bird[2]、cat[3]、deer[4]、dog[5]、frog[6]、horse[7]、ship[8]、truck[9]</p>
<p>根据测试结果判断为dog</p>
<blockquote>
<p>以上代码全部经过测试, 特别感谢: <a href="http://www.cnblogs.com/denny402/category/759199.html" target="_blank" rel="noopener">denny的学习专栏</a></p>
</blockquote>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/11/01/Fully-Convolutional-Networks/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Fully Convolutional Networks
        
      </div>
    </a>
  
  
    <a href="/2016/10/25/面向对象设计/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">面向对象设计</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>










</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 simshang
			<a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia Theme</a>
		</div>
      	<div class="footer-right">
			<a href="https://www.google.com/chrome/browser/desktop/index.html" target="_blank">Chrome Recommended </a>
		</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<div id="totop" style="position:fixed;bottom:85px;right:-5px;cursor: pointer;">
    <a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>
<script src="/js/totop.js"></script>

  </div>
</body>
</html>